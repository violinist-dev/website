<?php

/**
 * @file
 * West Kingdom customizations
 */

/**
 * Implements hook_module_implements_alter
 *
 * Make sure that our hook_form_alter is called after
 * revisioning_form_alter.
 */
function wk_module_implements_alter(&$implementations, $hook) {
  // Do nothing unless we implement the hook being tested (safety)
  if (isset($implementations['wk'])) {
    switch($hook) {
      // Make hook form_alter runs last
      case 'form_alter':
        $group = $implementations['wk'];
        unset($implementations['wk']);
        $implementations['wk'] = $group;
        break;
    }
  }
}

/**
 * Implements hook_form_alter
 */
function wk_form_alter(&$form, &$form_state) {
  // 0 == Modify current revision, no moderation
  // 1 == Create new revision, no moderation
  // 2 == Create new revision and moderate
  // Revisioning usually makes the default value '2', but
  // we prefer it to be '0' (no moderation unless specified).
  // TODO:  Check user access to make sure that current user
  // has the ability to publish content.
  if (isset($form['revision_information']['revision_operation'])) {
    $form['revision_information']['revision_operation']['#default_value'] = 1;
  }
}

/**
 * Hook token_info
 *
 * Declare tokens as_year and event_month.
 */
function wk_token_info() {
  // These tokens are only available for nodes of type 'cal_event'
  $node['as_year'] = array(
    'name' => t("Anno Societatis Year"),
    'description' => t('Year in Anno Societatis (AS). See http://www.sca.org/links/calendar.html.'),
  );
  $node['event_month'] = array(
    'name' => t("Event Month"),
    'description' => t('The month that the event is held in (reconed by starting date).'),
  );
  // Because of http://drupal.org/node/691078, we just hack in our own
  // field-based tokens here for now (cough).
  // These tokens are only available for nodes of type 'location' and
  // 'cal_event' (if the calendar event has a location set).
  $node['field_location_street'] = array(
    'name' => t("Location Street"),
    'description' => t('The street address that a location is located at.'),
  );
  $node['field_location_city'] = array(
    'name' => t("Location City"),
    'description' => t('The city that a location is in.'),
  );
  $node['field_location_province'] = array(
    'name' => t("Location Province"),
    'description' => t('The abbreviation for the province (State) that a location is in.'),
  );
  $node['field_location_province_name'] = array(
    'name' => t("Location Province Name"),
    'description' => t('The full name of the province (State) that a location is in.'),
  );
  $node['field_location_postal_code'] = array(
    'name' => t("Location Postal Code"),
    'description' => t('The postal code for the location.'),
  );
  $node['field_location_country'] = array(
    'name' => t("Location Country"),
    'description' => t('The country that a location is in.'),
  );
  $node['field_location_country_name'] = array(
    'name' => t("Location Country Name"),
    'description' => t('The full name of the country that a location is in.'),
  );
  $node['field_location_summary'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location (City, State).'),
  );
  $node['field_location_address'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location address (Street, City, State Zip).'),
  );
  return array(
    'tokens' => array('node' => $node),
  );
}

/**
 * Hook tokens
 *
 * Provide data for as_year and event_month tokens.
 */
function wk_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    if ($node->type == 'cal_event') {
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'as_year':
            $start_date = $node->field_date['und'][0]['value'];
            $as = wk_time_string_to_as($start_date);
            $replacements[$original] = 'AS' . $as;
            break;
          case 'event_month':
            $start_date = $node->field_date['und'][0]['value'];
            $timestamp=strtotime($start_date);
            $replacements[$original] = date('M', $timestamp);
            break;
        }
      }
    }
    $location_field = array();
    if (($node->type == 'location') && (isset($node->field_location['und'][0]))) {
      $location_field = $node->field_location['und'][0];
    }
    if (($node->type == 'cal_event') && (isset($node->field_event_site['und'][0]))) {
      $location_nid = $node->field_event_site['und'][0]['nid'];
      $location_node = node_load($location_nid);
      if (isset($location_node->field_location['und'][0])) {
        $location_field = $location_node->field_location['und'][0];
      }
    }
    if (isset($location_field['city']) && isset($location_field['province'])) {
      $location_field['summary'] = "(" . $location_field['city'] . ", " . $location_field['province'] . ")";
    }
    else {
      $location_field['summary'] = '(TBD)';
    }
    $location_address = '';
    if (isset($location_field['street'])) {
      $location_address = str_replace(array_keys($location_field), array_values($location_field), "(street, city province postal_code)");
    }
    else {
      $location_address = '(TBD)';
    }
    $location_field['address'] = $location_address;
    foreach ($tokens as $name => $original) {
      if (substr($name,0,15) == 'field_location_') {
        // $name is always 'field_location_xxx', so key is 'xxx'.
        $key = substr($name, 15);
        if (isset($location_field[$key])) {
          $replacements[$original] = $location_field[$key];
        }
        else {
          $replacements[$original] = '';
        }
      }
    }
  }
  return $replacements;
}

function wk_time_string_to_as($time_string) {
  $timestamp=strtotime($time_string);
  return wk_timestamp_to_as($timestamp);
}

function wk_timestamp_to_as($timestamp) {
  $date_info = getdate($timestamp);
  $as = $date_info['year'] - 1966;
  if ($date_info['mon'] >= 5) {
    $as = $as + 1;
  }
  return $as;
}

function wk_node_view($node, $view_mode, $langcode) {
  if (($node->type == 'cal_event') && ($view_mode == 'full')) {
    if (isset($node->content['field_event_site'][0]['body'])) {
      //$node->content['field_directions'] = $node->content['field_event_site'][0]['body'];
      if (!isset($node->content['field_directions'][0])) {
        $node->content['field_directions'] = array(
          '#theme' => 'field',
          '#weight' => 99,
          '#title' =>  'Directions',
          '#access' => TRUE,
          '#label_display' => 'above',
          '#view_mode' => 'full',
          '#language' => $langcode,
          '#field_name' => 'field_directions',
          '#field_type' => 'text',
          '#formatter' => 'text_default',
          '#entity_type' => 'node',
          '#bundle' => 'cal_event',
          '#object' => $node,
          '#items' => array(
            0 => array(
              'value' => '',
              'format' => NULL,
              'safe_value' => '')),
        );
      }
      $direction_diagram = '';
      if (isset($node->content['field_event_site'][0])) {
        $direction_diagram = render($node->content['field_event_site'][0]['field_directions_diagram']);
        hide($node->content['field_event_site'][0]['field_directions_diagram']);
      }
      $node->content['field_directions'][0]['#markup'] = $direction_diagram . $node->content['field_event_site'][0]['body'][0]['#markup'];
      hide($node->content['field_event_site'][0]['body']);
    }
  }
}

/**
 * Hook pathauto_alias alter.
 * See http://drupal.org/node/684132
 */
function wk_pathauto_alias_alter(&$alias, array &$context) {
  if (($context['op'] != 'return') && ($context['module'] == 'taxonomy_term')) {
    $term = $context['data']['term'];
    // Make calendar path aliases for branch group taxonomy terms (vid == 2)
    if ($term->vid == 2) {
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      // Remap calendar/tid to calendar/term_name, etc.
      // This is like pathauto for view arguments.  :)
      $path_list = array(
        "calendar/%",
        "meetings/%"        => "meetings/%/0",
        "meetings/%/all"    => "meetings/%/9",
        "events/%"          => "events/%/0",
        "events/%/all"      => "events/%/9",
        "events/%/feed"     => "events/%/0/feed",
        "events/%/all/feed" => "events/%/9/feed",
      );
      foreach ($path_list as $alias_path => $system_path) {
        if (is_numeric($alias_path)) {
          $alias_path = $system_path;
        }
        $system_path = str_replace("%", $term->tid, $system_path);
        $alias_path = str_replace("%", $machine_name, $alias_path);
        $existing_path = path_load($system_path);
        if (!empty($existing_path)) {
          path_delete($existing_path['pid']);
        }
        if (!empty($alias_path)) {
          $path_args = array("source" => $system_path, "alias" => $alias_path);
          path_save($path_args);
        }
      }
    }
  }
}

function _wk_term_short_name($term) {
  $short_name = '';

  if (isset($term->field_short_name[LANGUAGE_NONE][0]['value'])) {
    $short_name = $term->field_short_name[LANGUAGE_NONE][0]['value'];
  }
  if (empty($short_name)) {
    $short_name = _wk_shorten_name($term->name);
  }

  return $short_name;
}

function _wk_shorten_name($name) {
  $remove = array("Kingdom of ", "Principality of ", "Palatine Barony of ", "Barony of ", "Kingdom of ", "Shire of ", "Province of ", "Canton of ", "College of ", "Stronghold of ", "the ", " (incipiant)");

  foreach ($remove as $string_to_remove) {
    $name = str_replace($string_to_remove, '', $name);
  }

  return $name;
}

function _wk_to_machine_name($human_readable) {
  $machine_readable = strtolower($human_readable);
  $machine_readable = preg_replace("@['`]s@",'s',$machine_readable);
  $machine_readable = preg_replace('@[^a-z0-9_]+@','-',$machine_readable);
  return $machine_readable;
}
