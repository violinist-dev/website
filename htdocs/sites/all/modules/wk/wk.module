<?php

/**
 * @file
 * West Kingdom customizations
 */

/**
 * Implements hook_module_implements_alter
 *
 * Make sure that our hook_form_alter is called after
 * revisioning_form_alter.
 */
function wk_module_implements_alter(&$implementations, $hook) {
  // Do nothing unless we implement the hook being tested (safety)
  if (isset($implementations['wk'])) {
    switch($hook) {
      // Make hook form_alter runs last
      case 'form_alter':
        $group = $implementations['wk'];
        unset($implementations['wk']);
        $implementations['wk'] = $group;
        break;
    }
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * c.f. http://www.wunderkraut.com/blog/drupal-7-custom-node-view-modes/2010-12-20
 */
function wk_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['toc_entry'] = array(
    'label' => t('TOC entry'),
    'custom settings' => TRUE,
  );
}

/**
 * Add a hook suggestion for embedded content for the "officers" content type.
 *
 * http://drupal.stackexchange.com/questions/27025/how-to-provide-template-for-particular-view-mode
 */
function wk_preprocess_node(&$vars) {
  switch($vars['view_mode']) {
    case 'toc_entry':
      $vars['theme_hook_suggestions'][] = 'node__' . $vars['type'] . '__' . $vars['view_mode'];
      break;
  }
}

/**
 * Implements hook_form_alter
 */
function wk_form_alter(&$form, &$form_state) {
  if (($form['#form_id'] == 'contact_personal_form') || ($form['#form_id'] == 'og_contact_mail_page') || ($form['#form_id'] == 'contact_site_form')) {
    if (!empty($form['mail']['#default_value'])) {
      $form['mail']['#type'] = 'hidden';
      $form['name']['#type'] = 'hidden';
      $form['to']['#type'] = 'hidden';
      $form['#validate'][] = '_wk_form_validate_email_not_changed';
    }
  }
  // 0 == Modify current revision, no moderation
  // 1 == Create new revision, no moderation
  // 2 == Create new revision and moderate
  // Revisioning usually makes the default value '2', but
  // we prefer it to be '0' (no moderation unless specified).
  // TODO:  Check user access to make sure that current user
  // has the ability to publish content.
  if (isset($form['revision_information']['revision_operation'])) {
    $form['revision_information']['revision_operation']['#default_value'] = 1;
  }
}

/**
 * Don't allow users to change their personal email address
 * on contact forms.  This validate function will only be set
 * if the user was logged in; anonymous users get to put whatever
 * they want here.
 */
function _wk_form_validate_email_not_changed($form, &$form_state) {
  global $user;
  if ($form_state['values']['mail'] != $user->mail) {
    form_error($form, t('You may not change your email address on the contact form.'));
  }
}

/**
 * Hook token_info
 *
 * Declare tokens as_year and event_month.
 */
function wk_token_info() {
  // These tokens are only available for nodes of type 'cal_event'
  $node['as_year'] = array(
    'name' => t("Anno Societatis Year"),
    'description' => t('Year in Anno Societatis (AS). See http://www.sca.org/links/calendar.html.'),
  );
  $node['event_month'] = array(
    'name' => t("Event Month"),
    'description' => t('The month that the event is held in (reconed by starting date).'),
  );
  // Because of http://drupal.org/node/691078, we just hack in our own
  // field-based tokens here for now (cough).
  // These tokens are only available for nodes of type 'location' and
  // 'cal_event' (if the calendar event has a location set).
  $node['field_location_street'] = array(
    'name' => t("Location Street"),
    'description' => t('The street address that a location is located at.'),
  );
  $node['field_location_city'] = array(
    'name' => t("Location City"),
    'description' => t('The city that a location is in.'),
  );
  $node['field_location_province'] = array(
    'name' => t("Location Province"),
    'description' => t('The abbreviation for the province (State) that a location is in.'),
  );
  $node['field_location_province_name'] = array(
    'name' => t("Location Province Name"),
    'description' => t('The full name of the province (State) that a location is in.'),
  );
  $node['field_location_postal_code'] = array(
    'name' => t("Location Postal Code"),
    'description' => t('The postal code for the location.'),
  );
  $node['field_location_country'] = array(
    'name' => t("Location Country"),
    'description' => t('The country that a location is in.'),
  );
  $node['field_location_country_name'] = array(
    'name' => t("Location Country Name"),
    'description' => t('The full name of the country that a location is in.'),
  );
  $node['field_location_summary'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location (City, State).'),
  );
  $node['field_location_address'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location address (Street, City, State Zip).'),
  );
  return array(
    'tokens' => array('node' => $node),
  );
}

/**
 * Hook tokens
 *
 * Provide data for as_year and event_month tokens.
 */
function wk_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    if ($node->type == 'cal_event') {
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'as_year':
            $start_date = $node->field_date['und'][0]['value'];
            $as = wk_time_string_to_as($start_date);
            $replacements[$original] = 'AS' . $as;
            break;
          case 'event_month':
            $start_date = $node->field_date['und'][0]['value'];
            $timestamp=strtotime($start_date);
            $replacements[$original] = date('M', $timestamp);
            break;
        }
      }
    }
    $location_field = array();
    if (($node->type == 'location') && (isset($node->field_location['und'][0]))) {
      $location_field = $node->field_location['und'][0];
    }
    if (($node->type == 'cal_event') && (isset($node->field_event_site['und'][0]))) {
      $location_nid = $node->field_event_site['und'][0]['nid'];
      $location_node = node_load($location_nid);
      if (isset($location_node->field_location['und'][0])) {
        $location_field = $location_node->field_location['und'][0];
      }
    }
    if (isset($location_field['city']) && isset($location_field['province'])) {
      $location_field['summary'] = "(" . $location_field['city'] . ", " . $location_field['province'] . ")";
    }
    else {
      $location_field['summary'] = '(TBD)';
    }
    $location_address = '';
    if (isset($location_field['street'])) {
      $location_address = str_replace(array_keys($location_field), array_values($location_field), "(street, city province postal_code)");
    }
    else {
      $location_address = '(TBD)';
    }
    $location_field['address'] = $location_address;
    foreach ($tokens as $name => $original) {
      if (substr($name,0,15) == 'field_location_') {
        // $name is always 'field_location_xxx', so key is 'xxx'.
        $key = substr($name, 15);
        if (isset($location_field[$key])) {
          $replacements[$original] = $location_field[$key];
        }
        else {
          $replacements[$original] = '';
        }
      }
    }
  }
  return $replacements;
}

function wk_time_string_to_as($time_string) {
  $timestamp=strtotime($time_string);
  return wk_timestamp_to_as($timestamp);
}

function wk_timestamp_to_as($timestamp) {
  $date_info = getdate($timestamp);
  $as = $date_info['year'] - 1966;
  if ($date_info['mon'] >= 5) {
    $as = $as + 1;
  }
  return $as;
}

function wk_node_view($node, $view_mode, $langcode) {
  if (($node->type == 'cal_event') && ($view_mode == 'full')) {
    if (isset($node->content['field_event_site'][0]['body'])) {
      //$node->content['field_directions'] = $node->content['field_event_site'][0]['body'];
      if (!isset($node->content['field_directions'][0])) {
        $node->content['field_directions'] = array(
          '#theme' => 'field',
          '#weight' => 99,
          '#title' =>  'Directions',
          '#access' => TRUE,
          '#label_display' => 'above',
          '#view_mode' => 'full',
          '#language' => $langcode,
          '#field_name' => 'field_directions',
          '#field_type' => 'text',
          '#formatter' => 'text_default',
          '#entity_type' => 'node',
          '#bundle' => 'cal_event',
          '#object' => $node,
          '#items' => array(
            0 => array(
              'value' => '',
              'format' => NULL,
              'safe_value' => '')),
        );
      }
      $direction_diagram = '';
      if (isset($node->content['field_event_site'][0])) {
        $direction_diagram = render($node->content['field_event_site'][0]['field_directions_diagram']);
        hide($node->content['field_event_site'][0]['field_directions_diagram']);
      }
      $node->content['field_directions'][0]['#markup'] = $direction_diagram . $node->content['field_event_site'][0]['body'][0]['#markup'];
      hide($node->content['field_event_site'][0]['body']);
    }
  }
}

/**
 * Hook pathauto_alias alter.
 * See http://drupal.org/node/684132
 */
function wk_pathauto_alias_alter(&$alias, array &$context) {
  if (($context['op'] != 'return') && ($context['module'] == 'taxonomy_term')) {
    $term = $context['data']['term'];
    // Make calendar path aliases for branch group taxonomy terms (vid == 2)
    if ($term->vid == 2) {
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      // Remap calendar/tid to calendar/term_name, etc.
      // This is like pathauto for view arguments.  :)
      $path_list = array(
        "calendar/%",
        "meetings/%"        => "meetings/%/0",
        "meetings/%/all"    => "meetings/%/9",
        "events/%"          => "events/%/0",
        "events/%/all"      => "events/%/9",
        "events/%/feed"     => "events/%/0/feed",
        "events/%/all/feed" => "events/%/9/feed",
      );
      foreach ($path_list as $alias_path => $system_path) {
        if (is_numeric($alias_path)) {
          $alias_path = $system_path;
        }
        $system_path = str_replace("%", $term->tid, $system_path);
        $alias_path = str_replace("%", $machine_name, $alias_path);
        $existing_path = path_load($system_path);
        if (!empty($existing_path)) {
          path_delete($existing_path['pid']);
        }
        if (!empty($alias_path)) {
          $path_args = array("source" => $system_path, "alias" => $alias_path);
          path_save($path_args);
        }
      }
    }
  }
}

function _wk_term_short_name($term) {
  $short_name = '';

  if (isset($term->field_short_name[LANGUAGE_NONE][0]['value'])) {
    $short_name = $term->field_short_name[LANGUAGE_NONE][0]['value'];
  }
  if (empty($short_name)) {
    $short_name = _wk_shorten_name($term->name);
  }

  return $short_name;
}

function _wk_shorten_name($name) {
  $remove = array("Kingdom of ", "Principality of ", "Palatine Barony of ", "Barony of ", "Kingdom of ", "Shire of ", "Province of ", "Canton of ", "College of ", "Stronghold of ", "the ", " (incipiant)");

  foreach ($remove as $string_to_remove) {
    $name = str_replace($string_to_remove, '', $name);
  }

  return $name;
}

function _wk_to_machine_name($human_readable) {
  $machine_readable = strtolower($human_readable);
  $machine_readable = preg_replace("@['`]s@",'s',$machine_readable);
  $machine_readable = preg_replace('@[^a-z0-9_]+@','-',$machine_readable);
  return $machine_readable;
}

/**
 * wk_assign_officer
 *
 * This is called after a submitted regnum officer change request
 * form is approved.
 *
 * Assigns the specified user to an office in some branch group.
 * By default, the user will become the primary office holder;
 * however, it is also possible to assign deputies by this
 * method.
 *
 * If the specified user does not exist, a user record for the
 * user will be created.  An officer node will also be created
 * if one does not already exist.
 *
 * @param $user_officer_info
 *   Information about the office and office holder.
 *     'mail' (Required): email address for the officer
 *     'name' (Required if new): sca name of the officer
 *     'realname': Legal name of the officer
 *     'phone': Primary phone number of the officer
 *     'alternate-phone': Alternate phone number of the officer
 *     'deputy': TRUE if the user is a deputy; FALSE for the
 *        primary office holder.  Defaults to FALSE if not specified.
 *     'title': The title for the officer. Will be given a default
 *        title if none specified.
 * @param $branch_group_id
 *   The taxonomy term id for the branch group for the office
 * @param $office_id
 *   The taxonomy term id for the office type
 */
function wk_assign_officer($user_officer_info, $branch_group_id, $office_id) {
  // Get a reference to the user and the office being assigned to.
  $user = _wk_get_or_create_user($user_officer_info);
  //var_export($user);

  // If we create the node, we make it owned by the specified user;
  // by convention, group nodes are owned by the primary officer.
  // In the odd event that a deputy is assigned to an office that
  // does not exist (and therefore has no primary officer), then we
  // will create the node owned by anonymous (vacant).
  $owner_uid = $user_officer_info['deputy'] ? 0 : $user->uid;

  $officer_node = _wk_get_or_create_officer_node($branch_group_id, $office_id, $owner_uid);
  //var_export($officer_node);

  // If the user's email address has been changed, then
  // update it in the user record.
  if (!empty($user_officer_info['mail'])) {
    $user->mail = $user_officer_info['mail'];
  }
  // Similarly, update the user's name if it has
  // changed.
  if (!empty($user_officer_info['name'])) {
    $user->name = $user_officer_info['name'];
  }
  // Update the user's field-based information
  $field_map = _wk_user_info_update_field_map();
  $user_wrapper = entity_metadata_wrapper('user', $user);
  foreach ($field_map as $key => $variable) {
    if (!empty($user_officer_info[$key])) {
      $user_wrapper->$variable->set($user_officer_info[$key]);
    }
  }
  $user_wrapper->save();

  // If the user is the primary officer (not a deputy), then
  // change the owner of the officer node to be the specified user.
  $former_officer = FALSE;
  $retain_former_officer = TRUE;
  $former_officers_new_title = '';
  if ((!$user_officer_info['deputy']) && ($officer_node->uid != $user->uid)) {
    $former_officer = $officer_node->uid;
    $officer_node->uid = $user->uid;
  }
  // Odd situation: if the current officer is approved as a deputy,
  // then set the owner to the anonymous user (vacant office).
  if (($user_officer_info['deputy']) && ($officer_node->uid == $user->uid)) {
    $officer_node->uid = 0;
  }
  $officer_page_wrapper = entity_metadata_wrapper('node', $officer_node);
  $officer_page_wrapper->save();
  // Determine if the user already is a member of the group.
  // If not, add the user to the group.
  // TODO: maybe subscribe via:
  //   $ogm = og_group('node', $officer_node->nid, array('entity' => $user->uid));
  // This is the sanctioned API.  Simplify this later.
  $ogm = og_get_membership('node', $officer_node->nid, 'user', $user->uid);
  if (!$ogm) {
    $ogm = og_membership_create('node', $officer_node->nid, 'user', $user->uid, 'og_user_node');
  }
  // TODO: Make the member an administrative member of the group
  /*
  $rid = 0; // find role of administrative user
  og_role_grant('node', $officer_node->nid, $user->uid, $rid);
  */

  // Set the member's deputy / officer title
  $ogm_wrapper = entity_metadata_wrapper('og_membership', $ogm);
  $ogm_wrapper->field_type_of_deputy->set($user_officer_info['title']);
  $ogm_wrapper->field_weight->set($user_officer_info['deputy'] ? 0 : -10);
  $ogm_wrapper->save();

  // Should we keep the former officer listed as a deputy,
  // or remove the record?  For now, we retain the officer
  // as a 'Transitional Deputy ...' until manually deleted.
  if ($former_officer) {
    $ogm_former = og_get_membership('node', $officer_node->nid, 'user', $former_officer);
    if ($ogm_former) {
      if ($retain_former_officer) {
        $former_ogm_wrapper = entity_metadata_wrapper('og_membership', $ogm_former);
        if (empty($former_officers_new_title)) {
          $former_officers_new_title = "Transitional Deputy " . $former_ogm_wrapper->field_type_of_deputy->value();
        }
        $former_ogm_wrapper->field_type_of_deputy->set($former_officers_new_title);
        $former_ogm_wrapper->field_weight->set(10);
        $former_ogm_wrapper->save();
      }
      else {
        og_membership_delete($ogm_former->id);
      }
    }
  }
}

/**
 * Given a Regnum change submission, process the
 * request, assigning the specified user to the
 * desired office.
 *
 * @param $submission
 *   An EntityDrupalWrapper for the regnum_change entityform.
 *
 * To approve all submissions:
 *
 *   $toc = entityform_get_submissions('regnum_change');
 *   foreach ($toc as $id => $info) {
 *     $submission = new EntityDrupalWrapper('entityform', $id);
 *     wk_approve_officer($submission);
 *   }
 */
function wk_approve_officer($submission) {
  $field_map = _wk_regnum_change_field_map();
  $user_info = _wk_entity_to_data_array($submission, $field_map);
  $user_info = _wk_fix_up_submission_data($user_info);
  $branch_group_term = $submission->taxonomy_vocabulary_2->value();
  $branch_group_id = $branch_group_term[0]->tid;
  $office_term = $submission->field_office->value();
  $office_id = $office_term[0]->tid;
  wk_assign_officer($user_info, $branch_group_id, $office_id);
  // TODO: mark $submission as processed?
}

// If we need to find the groups that a user belongs to:
// $ drush ev '$u = user_load(4); return og_get_entity_groups("user", $u);'
// array(
//   'node' => array(
//     2 => '851',
//     22 => '889',
//     23 => '890',
//     25 => '892',
//   ),
// )

/**
 * Given a user ID or user record, return a list of submissions
 * that can be approved by the user.
 *
 * TODO:  Use this on the user's user page to show a list
 * of submissions he can approve.
 */
function wk_submissions_user_can_approve($user) {
  $result = array();

  // If a user id was passed in, load the user record
  if (!is_array($user)) {
    $user = user_load($user);
  }
  // Get the groups that the user is in.  It comes to us like this:
  // array(
  //   'node' => array(
  //     2 => '851',
  //     22 => '889',
  //     23 => '890',
  //     25 => '892',
  //   ),
  // )
  // We'll look at only the groups of type 'node', and will flip
  // the array around so that the group IDs are the key, and the
  // og_membership id is the value.
  $users_groups = og_get_entity_groups("user", $user);
  if (array_key_exists('node', $users_groups)) {
    $users_groups = array_flip($users_groups['node']);

    // Now iterate over all of the submissions.
    // TODO:  Filter out any submission that has been approved
    // or denied -- once we add code to indicate processed submissions.
    $toc = entityform_get_submissions('regnum_change');
    foreach ($toc as $id => $info) {
      $submission = new EntityDrupalWrapper('entityform', $id);
      $approval_offices = wk_approval_offices_for_submission($submission);
      $users_approval_offices = array_intersect_key($approval_offices, $users_groups);
      if (!empty($users_approval_offices)) {
        $approval_office_gids = array_keys($approval_offices);
        $primary_approver_gid = array_shift($approval_office_gids);
        // This user is the primary approver only if the
        // primary approver group is one of his groups, AND
        // he is the primary officer of that group.  Otherwise, he
        // is a secondary approver.
        $is_primary = array_key_exists($primary_approver_gid, $users_groups) && ($approval_offices[$primary_approver_gid]->uid = $user->uid);

        // Compose a result array that contains the submissions
        // the user can approve, along with information about
        // who else can approve the submission.
        $result[$id] = array(
          'submission' => $submission,
          'is-primary' => $is_primary,
          'approval-offices' => array_keys($approval_offices),
        );
      }
    }
  }

  return $result;
}

/**
 * Given a Regnum change submission, return a list
 * of all of the offices ('offices' og group nodes)
 * that have the right to approve the submission.
 *
 * The first office in the returned array is always
 * the "primary approver".  The other offices in the
 * list also have the ability to approve the submission,
 * but by convention should only do so if they know
 * that the primary approver approves of this action.
 *
 * TODO:  Use this to validate Regnum change requests.
 * If they are entered by someone who can approve the
 * submission, then offer to immediately approve it.
 */
function wk_approval_offices_for_submission($submission) {
  $approval_offices = array();

  // To start with, look up the branch group
  // and office that this submission is for.
  $branch_group_term = $submission->taxonomy_vocabulary_2->value();
  $branch_group_id = $branch_group_term[0]->tid;
  $office_term = $submission->field_office->value();
  $office_id = $office_term[0]->tid;

  // Constants defining the taxononmy terms
  // we are interested in.
  $seneschal_term = taxonomy_get_term_by_name('Seneschal', 'offices');
  $seneschal_tid = reset(array_keys($seneschal_term));
  $web_minister_term = taxonomy_get_term_by_name('Web Minister', 'offices');
  $web_minister_tid = reset(array_keys($web_minister_term));

  // First, find the primary approver.
  // The primary approver for any deputy position
  // is always the primary officer for the office
  $approver_branch_id = $branch_group_id;
  $approver_office_id = $office_id;
  if (!$submission->field_deputy->value()) {
    // If the submission is not for a deputy position,
    // then the primary approver is the seneschal of
    // the same branch group -- UNLESS the submission
    // is for the seneschal of the branch group, in
    // which case the primary approver is the seneschal
    // of the parent branch group.  The Kingdom Seneschal
    // must also approve the incoming Kingdom Seneschal.
    if ($approver_office_id != $seneschal_tid) {
      $approver_office_id = $seneschal_tid;
    }
    else {
      $parents = taxonomy_get_parents($approver_branch_id);
      if ($parents) {
        $parent = reset($parents);
        $approver_branch_id = $parent->tid;
      }
    }
  }
  _wk_add_approval_offices($approval_offices, $approver_branch_id, array($approver_office_id));

  // We will allow the Seneschal and Web Minister of
  // the same branch group to be alternate approvers
  // for the Regnum change.
  _wk_add_approval_offices($approval_offices, $approver_branch_id, array($seneschal_tid, $web_minister_tid));

  // Next, we'll walk up the branch group hierarchy
  // until we get to the top.  Note that the top is
  // Corporate, which we do not process.  Note also
  // that we do not bother anyone other than the officers
  // of the immediate group with approval requests
  // of deputies.
  if (!$submission->field_deputy->value()) {
    // We will only admit to at most one parent per branch group.
    $parents = taxonomy_get_parents($approver_branch_id);
    while ($parents) {
      $parent = reset($parents);
      $approver_branch_id = $parent->tid;
      _wk_add_approval_offices($approval_offices, $approver_branch_id, array($seneschal_tid, $web_minister_tid, $office_id));
      // For each branch group above the first, we allow,
      // as an alternate approver, the Seneschal, the Web
      // Minister, and the officer above the office
      $parents = taxonomy_get_parents($approver_branch_id);
    }
  }

  return $approval_offices;
}

function _wk_add_approval_offices(&$approval_offices, $approver_branch_id, $approver_officer_list) {
  foreach ($approver_officer_list as $tid) {
    $approver = _wk_find_officer_node($approver_branch_id, $tid);
    if ($approver) {
      $approval_offices[$approver->nid] = $approver;
    }
  }
}

function _wk_get_or_create_officer_node($branch_group_id, $office_id, $owner_uid) {
  $node = _wk_find_officer_node();
  if (!$node) {
    $node = _wk_create_officer_node($branch_group_id, $office_id);
  }
  return $node;
}

function _wk_find_officer_node($branch_group_id, $office_id) {
  $node = FALSE;
  $query = new EntityFieldQuery();
  $entities = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('officers'))
    ->propertyCondition('status', 1) // it might actually cause a problem to include this
    ->fieldCondition('field_office', 'tid', $office_id, '=')
    ->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch_group_id, '=')
    ->execute();
  if (!empty($entities)) {
    // There should never be more than one officer node
    $nids = array_keys($entities['node']);
    $node = node_load($nids[0]);
  }
  return $node;
}

function _wk_create_officer_node($branch_group_id, $office_id, $owner_uid) {
  $branch_term = taxonomy_term_load($branch_group_id);
  $office_term = taxonomy_term_load($office_id);
  $node = new stdClass();
  $node->type = 'officers';
  node_object_prepare($node);
  $node->title    = $branch_term->name . ' ' . $office_term->name;
  $node->language = LANGUAGE_NONE;
  //$node->created = strtotime($item->created_on);
  $node->uid = $owner_uid;

  $node->taxonomy_vocabulary_2[$node->language][] = array('tid' => $branch_group_id);
  $node->field_office[$node->language][] = array('tid' => $office_id);

  // TODO: We should add a field to $office_term that contains the
  // template text for new officer nodes that we can use here.
  $node->body[$node->language][0] = array(
    'value' => 'Placeholde body',
    'format' => '1',
  );

  // n.b. Pathauto hooks fire, so node will be given a standard-format url
  node_save($node);

  return $node;
}

function _wk_get_or_create_user($user_info) {
  $user_info += array(
    'name' => '',
    'mail' => '',
  );
  $query = "SELECT uid FROM {users} WHERE name = :name OR mail = :mail";
  $parameters[':mail'] = $user_info['mail'];
  $parameters[':name'] = $user_info['name'];
  if (empty($user_info['name'])) {
    $query = "SELECT uid FROM {users} WHERE mail = :mail";
    unset($parameters[':name']);
  }
  elseif (empty($user_info['mail'])) {
    $query = "SELECT uid FROM {users} WHERE name = :name";
    unset($parameters[':mail']);
  }

  $result = db_query($query, $parameters);
  $uid = drush_db_result($result);

  // If the user record does not exist, then create it.
  if (!$uid) {
    $pass = _wk_random_password();
    $new_user = array(
      'name' => $user_info['name'],
      'pass' => $pass,
      'mail' => $user_info['mail'],
      'access' => '0',
      'status' => 1,
    );
    $new_user_object = user_save(NULL, $new_user, NULL);
    $uid = $new_user_object->uid;
  }
  $user = user_load(array('uid' => $uid));

  return $user;
}

function _wk_regnum_change_field_map() {
  return array(
    'name' => 'field_society_name',
    'realname' => 'field_real_name',
    'branch' => 'taxonomy_vocabulary_2',
    'office' => 'field_office',
    'deputy' => 'field_deputy',
    'title' => 'field_type_of_deputy',
    'mail' => 'field_email_address',
    'phone' => 'field_phone_number',
    'alternate-phone' => 'field_alternate_phone',
    'membership-id' => 'field_membership_number',
    'info' => 'field_additional_information',
  );
}

function _wk_user_info_update_field_map() {
  return array(
    'realname' => 'field_real_name',
    'phone' => 'field_phone_number',
    'alternate-phone' => 'field_alternate_phone',
    'membership-id' => 'field_membership_number',
  );
}

function _wk_fix_up_submission_data($data) {
  if (empty($data['title'])) {
    if ($data['deputy']) {
      $data['office'] = "Deputy " . $data['office'];
    }
    $data['title'] = str_replace(array_keys($data), array_values($data), "branch office");
  }
  return $data;
}

function _wk_map_to_dt_data($map) {
  $dt_data = array();
  foreach ($map as $key => $value) {
    $dt_data['!' . $key] = $value;
  }
  return $dt_data;
}

function _wk_entity_to_data_array($e, $field_map) {
  $data = array();
  foreach ($field_map as $key => $variable) {
    $data[$key] = $e->$variable->value();
    if (!is_string($data[$key]) && !is_bool($data[$key])) {
      $a = (array)$data[$key];
      if (is_array($a) && !empty($a) && is_object($a[0]) && isset($a[0]->tid)) {
        $data[$key] = $a[0]->name;
      }
      else {
        $data[$key] = '';
      }
    }
  }
  return $data;
}

function _wk_random_password($length=16) {
  $vowels = 'aeuyAEUY@#$*23456789';
  $consonants = 'bdghjmnpqrstvzBDGHJLMNPQRSTVWXZ';
  $password = '';
  for ($i = 0; $i < $length; $i++) {
    if ($i % 2) {
      $password .= $consonants[(rand() % strlen($consonants))];
    } else {
      $password .= $vowels[(rand() % strlen($vowels))];
    }
  }
  return $password;
}
