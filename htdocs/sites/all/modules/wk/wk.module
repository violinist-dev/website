<?php

/**
 * @file
 * West Kingdom customizations
 */

// Calendar status values (used internally only; not stored in database)

define("CALENDAR_STATUS_CLOSED", "CLOSED");
define("CALENDAR_STATUS_PREPARING", "PREPARING");
define("CALENDAR_STATUS_ONE_EVENT", "ONE_EVENT");
define("CALENDAR_STATUS_TWO_EVENTS", "TWO_EVENTS");

define("UNLIMITED", 999);

// Some magic numbers.  TODO: move to configuration

define("SOCIETY_TID", 75);
define("KINGDOM_OF_THE_WEST_TID", 2);

define("SENESCHAL_TID", 84);

define("KINGDOM_WEBMINISTER_GID", 851);
define("KINGDOM_SENESCHAL_GID", 989);

// DateTime::W3C = "Y-m-d\TH:i:sP"
// These are not quite W3C formats, because they are
// missing the timezone component.
define("W3C_NoTZ", "Y-m-d\TH:i:s");
define("W3C_BeginningOfDay", "Y-m-d\T00:00:00");
define("W3C_Noon", "Y-m-d\T12:00:00");
define("W3C_EndOfDay", "Y-m-d\T23:59:59");

// Drupal time formats = "Y-m-d H:i:s"
define("Drupal_BeginningOfDay", "Y-m-d 00:00:00");
define("Drupal_Noon", "Y-m-d 12:00:00");
define("Drupal_EndOfDay", "Y-m-d 23:59:59");

/**
 * Implements hook_module_implements_alter
 *
 * Make sure that our hook_form_alter is called after
 * revisioning_form_alter.
 */
function wk_module_implements_alter(&$implementations, $hook) {
  // Do nothing unless we implement the hook being tested (safety)
  if (isset($implementations['wk'])) {
    switch($hook) {
      // Make hook form_alter runs last
      case 'form_alter':
        $group = $implementations['wk'];
        unset($implementations['wk']);
        $implementations['wk'] = $group;
        break;
    }
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * c.f. http://www.wunderkraut.com/blog/drupal-7-custom-node-view-modes/2010-12-20
 */
function wk_entity_info_alter(&$entity_info) {
  $entity_info['node']['view modes']['toc_entry'] = array(
    'label' => t('TOC entry'),
    'custom settings' => TRUE,
  );
}

function wk_preprocess_page(&$variables) {
  if (isset($variables['node'])) {
    $fn = 'wk_preprocess_page__' . $variables['node']->type;
    if (function_exists($fn)) {
      $fn($variables);
    }
  }

  // http://rickmanelius.com/article/tell-facebook-which-image-share
  $img = FALSE;
  // If there is a page picture, use that.
  if(isset($variables['node']->field_page_picture[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->field_page_picture[LANGUAGE_NONE][0]['uri']);
  }
  // If there is no page picture, but there is a branch group
  // associated with the page, then use that.
  elseif(isset($variables['node']->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['taxonomy_term']->field_arms[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->taxonomy_vocabulary_2[LANGUAGE_NONE][0]['taxonomy_term']->field_arms[LANGUAGE_NONE][0]['uri']);
  }
  // If someone is sharing an officer page, then use the
  // officer badge as the thumbnail image for Facebook.
  elseif(isset($variables['node']->field_office[LANGUAGE_NONE][0]['taxonomy_term']->field_badge[LANGUAGE_NONE][0]['uri'])) {
    $img = file_create_url($variables['node']->field_office[LANGUAGE_NONE][0]['taxonomy_term']->field_badge[LANGUAGE_NONE][0]['uri']);
  }
  if ($img) {
    $element = array(
      '#tag' => 'meta',
      '#attributes' => array(
        "property" => "og:image",
        "content" => $img,
      ),
    );
    drupal_add_html_head($element,'facebook_share_image');
  }
}

function wk_preprocess_page__officers(&$variables) {
  global $user;
  $output = '';
  $office_title='';
  $branch_group_terms=FALSE;
  $officer_terms=FALSE;
  $node = $variables['node'];
  if (isset($node->taxonomy_vocabulary_2[LANGUAGE_NONE])) {
    $branch_group_terms = $node->taxonomy_vocabulary_2[LANGUAGE_NONE];
  }
  if (isset($node->field_office[LANGUAGE_NONE])) {
    $officer_terms = $node->field_office[LANGUAGE_NONE];
  }
  if ($branch_group_terms) {
    $branch_output = '';
    foreach ($branch_group_terms as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_arms');
        if (!empty($view)) {
          $branch_output .= render($view);
        }
      }
    }
    // We used to put the branch group arms in the header, but no longer.
    // Maybe later we will put $branch_output somewhere else, more appropriate.
  }
  if ($officer_terms) {
    $officer_output = '';
    foreach ($officer_terms as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_badge');
        if (!empty($view)) {
          $officer_output .= render($view);
        }
        if (empty($office_title)) {
          $office_title = ' the ';
        }
        else {
          $office_title .= ' and ';
        }
        $office_title .= $term['taxonomy_term']->name;
      }
    }
    if (!empty($officer_output)) {
      $output .= "<div class='officer-badge'>$officer_output</div>";
    }
  }
  if (!empty($output)) {
    $variables['title_prefix']['#markup'] = "
<div class='officer-badges'>
  $output
</div>";
  }
  $uri = request_uri();
  $variables['title_suffix']['#markup'] = "<a href='$uri/contact' class='link-contact clearfix'>Contact $office_title</a>";
}

function wk_preprocess_page__cal_event(&$variables) {
  // Inelegant, but we need to filter out "edit" page (and others) somehow.
  $value = arg(2);
  if (empty($value)) {
    $node = $variables['node'];
    // Output device arms before the page title
    $output = '';
    foreach ($node->taxonomy_vocabulary_2[LANGUAGE_NONE] as $index => $term) {
      if (isset($term['taxonomy_term'])) {
        $view = field_view_field('taxonomy_term', $term['taxonomy_term'], 'field_arms');
        if (!empty($view)) {
          $output .= render($view);
        }
      }
    }
    if (!empty($output)) {
      $variables['title_prefix']['#markup'] = "
  <div class='calendar-event-arms'>
    <div class='left-arms'>$output</div>
    <div class='right-arms'>$output</div>
  </div>";
    }
    // Output additional information about the event below the page title
    $cal_event_location_long_summary_markup = '';
    $cal_event_date = wk_node_field_date_render_array($node);
    $variables['cal_event_date'] = $cal_event_date;
    $variables['cal_event_branch'] = field_view_field('node', $node, 'taxonomy_vocabulary_2', 'default'); // $node->taxonomy_vocabulary_2;
    if (isset($node->field_event_site[LANGUAGE_NONE][0]['node']) && isset($node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0])) {
      $city = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['city'];
      $province = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['province'];
      $province_name = $node->field_event_site[LANGUAGE_NONE][0]['node']->field_location[LANGUAGE_NONE][0]['province_name'];
      if (!empty($city) && !empty($province)) {
        $variables['cal_event_location_summary'] = '(' . $city . ', ' . $province . ')';
        $variables['cal_event_location_long_summary'] =  $city . ', ' . $province_name;
        $cal_event_location_long_summary_markup = '<div class="cal-event-location-long-summary">' . $variables['cal_event_location_long_summary'] . '</div>';
      }
    }
    $variables['title_suffix']['#markup'] = '
    <div class="event-info">
      ' . render($cal_event_date) . $cal_event_location_long_summary_markup . render($variables['cal_event_branch']) . '
    </div>
  ';
  }
}

function _wk_render_event_list($event_list) {
  $result = "";
  $link_options = array();
  foreach ($event_list as $nid => $node) {
    $link_content = $node->title;
    $term_info = reset($node->taxonomy_vocabulary_2[$node->language]);
    if ($term_info) {
      $term = false;
      if (isset($term_info['taxonomy_term'])) {
        $term = $term_info['taxonomy_term'];
      }
      elseif (isset($term_info['tid'])) {
        $term = taxonomy_term_load($term_info['tid']);
      }
      if ($term) {
        $e = entity_metadata_wrapper("taxonomy_term", $term);
        $img_info = $e->field_arms->value();
        if ($img_info) {
          $image_attributes = array('alt' => $term->name);
          $format_string = 'd F Y';
          $dv = $node->field_date[$node->language][0];
          $conflict_dates = _wk_format_date_range($dv, $format_string);
          $title = $term->name . ' - ' . $node->title . ', ' . $conflict_dates;
          $link_content = theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes));
          $link_options['html'] = true;
          $link_options['attributes']['class'] = array('conflicting-event');
        }
      }
    }

    $result .= l($link_content, 'node/' . $node->nid, $link_options) . ' ';
  }
  return $result;
}

/**
 * Drupal trims usernames to prevent the layout of certain
 * views from wrapping awkwardly.  Long names are very common
 * in the West, though, and trimming them looks bad.  This
 * hook puts them back to their full width; we'll just have
 * to fix any layout problems this may cause as they come up.
 */
function wk_process_username(&$variables) {
  $variables['name'] = check_plain($variables['name_raw']);
}

/**
 * Add a hook suggestion for embedded content for the "officers" content type.
 *
 * http://drupal.stackexchange.com/questions/27025/how-to-provide-template-for-particular-view-mode
 */
function wk_preprocess_node(&$variables) {
  switch($variables['view_mode']) {
    case 'toc_entry':
      $variables['theme_hook_suggestions'][] = 'node__' . $variables['type'] . '__' . $variables['view_mode'];
      break;
  }

  if (isset($variables['node'])) {
    $fn = 'wk_preprocess_node__' . $variables['node']->type;
    if (function_exists($fn)) {
      $fn($variables);
    }
  }
}

function wk_preprocess_node__officers(&$variables) {
  hide($variables['content']['field_office']);
  hide($variables['content']['taxonomy_vocabulary_2']);
}



function wk_preprocess_node__cal_event(&$variables) {
  if ($variables['teaser']) {
    $node = $variables['node'];
    $variables['content']['body'][0]['#markup'] = '<div class="teaser-date">' . wk_render_node_field_date($node) . '</div>' . text_summary($variables['content']['body'][0]['#markup'], NULL, 200);
    if (isset($node->taxonomy_vocabulary_2[LANGUAGE_NONE])) {
      $branch_group_terms = $node->taxonomy_vocabulary_2[LANGUAGE_NONE];
    }
    if ($branch_group_terms) {
      $branch_output = '';
      foreach ($branch_group_terms as $index => $term) {
        if (isset($term['tid'])) {
          $t = taxonomy_term_load($term['tid']);
          $view = field_view_field("taxonomy_term", $t, "field_arms");
          if (!empty($view)) {
            $branch_output .= render($view);
          }
        }
      }
      if (!empty($branch_output)) {
        $variables['title'] = "<div class='cal-event-branch'>$branch_output</div>" . $variables['title'];
      }
    }
  }
}

function wk_taxonomy_tree_initial_minimized_state(&$element) {
  $has_selected_elements = FALSE;
  foreach ($element as $tid => $data) {
    if (($tid[0] != '#') && is_numeric($tid)) {
      $is_selected = $element[$tid][$tid]['#value'];
      if (array_key_exists($tid . '-children', $element[$tid])) {
        $is_selected |= wk_taxonomy_tree_initial_minimized_state($element[$tid][$tid . '-children']);
        if (!$is_selected) {
          $element[$tid][$tid . '-children']['#start_minimized'] = TRUE;
          $element[$tid][$tid . '-children']['#level_start_minimized'] = TRUE;
        }
      }
      if (!$is_selected) {
        $element[$tid]['#level_start_minimized'] = TRUE;
      }
      $has_selected_elements |= $is_selected;
    }
  }
  return $has_selected_elements;
}

function wk_taxonomy_tree_form_element_alter(&$element) {
  $has_selected_elements = FALSE;
  foreach ($element as $tid => $data) {
    if (($tid[0] != '#') && is_numeric($tid)) {
      $is_selected = FALSE;
      wk_taxonomy_tree_form_element_term_alter($element[$tid][$tid], $tid);
      $is_selected = $element[$tid][$tid]['#value'];
      if (array_key_exists($tid . '-children', $element[$tid])) {
        $is_selected |= wk_taxonomy_tree_form_element_alter($element[$tid][$tid . '-children']);
        if (!$is_selected) {
          $element[$tid][$tid . '-children']['#start_minimized'] = TRUE;
          $element[$tid][$tid . '-children']['#level_start_minimized'] = TRUE;
        }
      }
      if (!$is_selected) {
        $element[$tid]['#level_start_minimized'] = TRUE;
      }
      $has_selected_elements |= $is_selected;
    }
  }
  return $has_selected_elements;
}

/**
 * Alter the data built by term_reference_tree.widget.inc.
 * @see: _term_reference_tree_build_item()
 */
function wk_taxonomy_tree_form_element_term_alter(&$element, $tid) {
  $term = taxonomy_term_load($tid);
  $term_render_array = taxonomy_term_view($term, 'term_with_icon');
  // Probably better to just do this:
  //   $element['#title'] = drupal_render($term_render_array);
  // We would need to re-order the title and remove the link from it, though.
  $label_prefix = '';
  $suffix = '';
  foreach ($term_render_array as $key => $child) {
    if ($key[0] != '#') {
      if (array_key_exists('#field_type', $child) && ($child['#field_type'] == 'image')) {
        $label_prefix .= drupal_render($child);
      }
      else {
        $suffix .= strip_tags(drupal_render($child), '<div>');
      }
    }
  }
  $label_key = $element['#type'] == 'checkbox_tree_label' ? '#value' : '#title';
  $element[$label_key] = $label_prefix . $element[$label_key] . $suffix;
}

function wk_term_with_icon_form_element_after_build($form_element, &$form_state) {
  wk_taxonomy_tree_form_element_alter($form_element[0]);
  // Reorganize the tree under the term "The Society for Creative Anachronism"
  if (array_key_exists(SOCIETY_TID, $form_element[0]) && array_key_exists(KINGDOM_OF_THE_WEST_TID, $form_element[0][SOCIETY_TID][SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID])) {
    $corpora_element = $form_element[0][SOCIETY_TID];
    $corpora_element['#term-name'] = t("Other Kingdoms");
    $label_key = $corpora_element[SOCIETY_TID]['#type'] == 'checkbox_tree_label' ? '#value' : '#title';
    $corpora_element[SOCIETY_TID][$label_key] = $corpora_element['#term-name'];
    unset($form_element[0][SOCIETY_TID]);
    $form_element[0][KINGDOM_OF_THE_WEST_TID] = $corpora_element[SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID];
    unset($corpora_element[SOCIETY_TID . '-children'][KINGDOM_OF_THE_WEST_TID]);
    $form_element[0][SOCIETY_TID] = $corpora_element;
  }
  $has_selected = wk_taxonomy_tree_initial_minimized_state($form_element[0]);
  if (!$has_selected) {
    foreach ($form_element[0] as $tid => $data) {
      if (($tid[0] != '#') && is_numeric($tid)) {
        $form_element[0][$tid]['#level_start_minimized'] = FALSE;
        $form_element[0][$tid][$tid . '-children']['#start_minimized'] = FALSE;
        $form_element[0][$tid][$tid . '-children']['#level_start_minimized'] = FALSE;
        break;
      }
    }
  }
  return $form_element;
}

function wk_form_alter_taxonomy_tree_with_icon_fields(&$element) {
  if (is_array($element)) {
    foreach ($element as $key => $data) {
      if ($key[0] != '#') {
        if (!is_numeric($key) && in_array($key, array('taxonomy_vocabulary_2', 'field_office'))) {
          $language = $element[$key]['#language'];
          if ((isset($element[$key][$language])) && ($element[$key][$language]['#type'] == 'checkbox_tree')) {
            $element[$key]['#attributes']['class'][] = 'term-with-icon-variant';
            $element[$key][$language]['#after_build'][] = 'wk_term_with_icon_form_element_after_build';
          }
        }
        else {
          wk_form_alter_taxonomy_tree_with_icon_fields($element[$key]);
        }
      }
    }
  }
}

// Make a calendar date request to hold the specified calendar event
// again during the following year.  Note that this code is only used
// when the Seneschal or Calendar deputy begins the calendar planning
// process for the next year.  At that time, date requests for all of
// the "carryover" events are created by repeatedly calling this function.
function wk_create_calendar_date_request($node, $additional_delta = 0) {
  // Just ignore this event if we have already made
  // a date request to re-hold it next year.
  $date_request_info = _wk_find_date_request_for_event($node->nid);
  if (empty($date_request_info)) {
    global $user;

    // Create an entity and set the time and user who created it
    $date_request_entity = entityform_create(array("type" => "calendar_date_request"));
    $date_request_entity->uid = $user->uid;
    $date_request_entity->changed = time();

    // The rest of our manipulations will be with an entity wrapper
    $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $date_request->created = time();
    $date_request->field_event_name->set($node->title);
    $date_request->field_placeholder_event_descript->set(t("More information will be provided as it becomes available."));
    $date_request->field_repeat_of_event->set($node->nid);
    $date_request->field_society_name->set($user->name);
    $date_request->field_email_address->set($user->mail);

    $v = $node->taxonomy_vocabulary_2[$node->language];
    if (!empty($v)) {
      $branch_tids = array();
      foreach ($v as $index => $info) {
        $branch_tids[] = $info['tid'];
      }
      $date_request->taxonomy_vocabulary_2->set($branch_tids);
    }

    $dv = $node->field_date[$node->language][0];
    $start_date = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    $start_date->setTime(12,0,0);
    $end_date = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
    $end_date->setTime(12,0,0);
    $duration = $start_date->diff($end_date);

    // Add one year, and then find the nearest
    // date that starts on the same day of the week
    // as the original event.
    $original_dow = $start_date->format("w");
    $start_date->modify("+1 year");
    $delta_dow = ($original_dow - $start_date->format("w")) % 7;
    $days_interval = new DateInterval( "P" . abs($delta_dow) . "D" );
    if ($delta_dow < 0) {
      $days_interval->invert = 1;
    }
    $start_date->add($days_interval);
    if ($additional_delta) {
      $start_date->modify("$additional_delta weeks");
    }
    // Calculate a new end date at the same duration
    // as the original event
    $end_date = new DateTime($start_date->format(W3C_Noon), $start_date->getTimezone());
    $end_date->add($duration);

    $v = $date_request->field_first_choice_date->value();
    $v['value'] = $start_date->format(W3C_Noon);
    $v['value2'] = $end_date->format(W3C_Noon);
    $date_request->field_first_choice_date->set($v);

    // Make the first alternate the week after
    $alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
    $alternate->modify("+1 week");

    $alternate_formatted = $alternate->format('Y-m-d');
    $date_request->field_alternate_date->set(strtotime($alternate_formatted . 'T12:00:00'));

    // Make the second alternate the week before
    $second_alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
    $second_alternate->modify("-1 week");

    $second_alternate_formatted = $second_alternate->format('Y-m-d');
    $date_request->field_second_alternate_date->set(strtotime($second_alternate_formatted . 'T12:00:00'));

    $date_request->save();
  }
}

function wk_form_alter__calendar_date_request_entityform_edit_form(&$form, &$form_state) {
  //dpm($form);
  global $user;
  $menu = menu_get_item();
  //dpm($menu);
  if (count($menu['page_arguments']) > 2) {
    $nid = $menu['page_arguments'][2];
    $node = node_load($nid);
    $additional_delta = 0;
    if (count($menu['page_arguments']) > 3) {
      $additional_delta = $menu['page_arguments'][3];
    }
    // TODO: Error checking and error display
    if ($node) {
      //dpm($node);
      // Copy the title
      $form['field_event_name'][LANGUAGE_NONE][0]['value']['#default_value'] = $node->title;
      $form['field_repeat_of_event'][LANGUAGE_NONE][0]['nid']['#default_value'] = $node->nid;
      // Copy the branch group or branch groups
      $group_ids = array();
      foreach ($node->taxonomy_vocabulary_2[LANGUAGE_NONE] as $index => $info) {
        $tid = $info['tid'];
        $group_ids[$tid] = $tid;
        // TODO: look up seneschal for this branch group
      }
      $form['taxonomy_vocabulary_2'][LANGUAGE_NONE]['#default_value'] = $group_ids;
      // Find the start and end date of the original event
      $dv = $node->field_date[LANGUAGE_NONE][0];
      $start_date = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
      $start_date->setTime(12,0,0);
      $end_date = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
      $end_date->setTime(12,0,0);
      $duration = $start_date->diff($end_date);
      $previous_event_date = $start_date->format("d F, Y");
      $previous_event_title = l($node->title, 'node/' . $node->nid);

      // Add one year, and then find the nearest
      // date that starts on the same day of the week
      // as the original event.
      $original_dow = $start_date->format("w");
      $start_date->modify("+1 year");
      $delta_dow = ($original_dow - $start_date->format("w")) % 7;
      $days_interval = new DateInterval( "P" . abs($delta_dow) . "D" );
      if ($delta_dow < 0) {
        $days_interval->invert = 1;
      }
      $start_date->add($days_interval);
      if ($additional_delta) {
        $start_date->modify("$additional_delta weeks");
      }
      // Calculate a new end date at the same duration
      // as the original event
      $end_date = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $end_date->add($duration);
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value'] =  $dv;
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $start_date->format("Y-m-d H:i:s");
      $form['field_first_choice_date'][LANGUAGE_NONE][0]['#default_value']['value2'] = $end_date->format("Y-m-d H:i:s");
      $nextyear = $start_date->format("Y");

      // Make the first alternate the week after
      $alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $alternate->modify("+1 week");
      $form['field_alternate_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $alternate->format("Y-m-d H:i:s");
      // Make the second alternate the week before
      $second_alternate = new DateTime($start_date->format("Y-m-d H:i:s"), $start_date->getTimezone());
      $second_alternate->modify("-1 week");
      $form['field_second_alternate_date'][LANGUAGE_NONE][0]['#default_value']['value'] = $second_alternate->format("Y-m-d H:i:s");
      // Inform the user that this form is related to an existing
      // event description node.
      drupal_set_message(t("Submit a calendar date request below to re-hold the event !previous from !prevdate again in !nextyear. <a href='/calendar-date-request'>Cancel</a>", array(
          '!previous' => $previous_event_title,
          '!prevdate' => $previous_event_date,
          '!nextyear' => $nextyear,
          '!cancelurl' => '/calendar-date-request')));
    }
  }
  else {
    // TODO: Only fill this in if the current user is a seneschal
    if (isset($form['field_society_name']) && empty($form['field_society_name'][LANGUAGE_NONE][0]['value']['#default_value'])) {
      $form['field_society_name'][LANGUAGE_NONE][0]['value']['#default_value'] = $user->name;
    }
  }
}

/**
 * Implements hook_form_alter
 */
function wk_form_alter(&$form, &$form_state) {
  $fn = 'wk_form_alter__' . strtr($form['#id'], '-', '_');
  if (function_exists($fn)) {
    $fn($form, $form_state);
  }

  // Search for occurances of checkbox_tree fields that we want to alter.
  wk_form_alter_taxonomy_tree_with_icon_fields($form);

  if (($form['#form_id'] == 'contact_personal_form') || ($form['#form_id'] == 'og_contact_mail_page') || ($form['#form_id'] == 'contact_site_form')) {
    if (!empty($form['mail']['#default_value'])) {
      $form['mail']['#type'] = 'hidden';
      $form['name']['#type'] = 'hidden';
      $form['to']['#type'] = 'hidden';
      $form['#validate'][] = '_wk_form_validate_email_not_changed';
    }
  }

  if (!empty($form['#node_edit_form'])) {
    // This next block is copied from the 'revisioning' module, which for some reason
    // only shows these radios for users with 'administer nodes'.  We allow it for
    // any user who can publish the node.
    $node = &$form['#node'];
    $is_moderated_content = isset($node->revision_moderation)
      ? $node->revision_moderation
      : revisioning_content_is_moderated($form['type']['#value'], $node);
    if (revisioning_user_node_access('publish revisions', $node)) {
      // Expand and move this vertical tab to top, so that it's in user's face
      if (isset($form['menu'])) {
        $form['menu']['#collapsed'] = TRUE;
      }
      $form['revision_information']['#collapsed'] = FALSE;
      $form['revision_information']['#weight'] = -3;

      $options = array();
      if (isset($node->nid)) {
        $options[NO_REVISION] = t('Modify current revision, no moderation');
      }
      $options[NEW_REVISION_NO_MODERATTION]  = t('Create new revision, no moderation');
      $options[NEW_REVISION_WITH_MODERATION] = t('Create new revision and moderate');

      // This radio selection will appear in hook_node_presave as $node->revision_operation
      $form['revision_information']['revision_operation'] = array(
        '#title' => t('Revision creation and moderation options'),
        '#description' => t('Moderation means that the new revision is not publicly visible until approved by someone with the appropriate permissions.'),
        '#type' => 'radios',
        '#options' => $options,
        '#default_value' => isset($node->nid)
          ? (int)$node->revision + (int)$is_moderated_content
          : ($is_moderated_content ? NEW_REVISION_WITH_MODERATION : NEW_REVISION_NO_MODERATTION)
      );
      unset($form['revision_information']['revision']);

      // Add javascript to show/hide the "Published" checkbox if the user
      // presses one of the first two radio buttons. Also updates summary tabs.
      $js_file = drupal_get_path('module', 'revisioning') . '/revision-radios.js';
      drupal_add_js($js_file, array('weight' => 1)); // after node.js
      // If preference specifies that "no moderation" is the default, then change the control default value
      if (variable_get('wk_no_moderation_by_default', TRUE)) {
        $form['revision_information']['revision_operation']['#default_value'] = NEW_REVISION_NO_MODERATTION;
      }
    }
  }

}

function wk_form_alter__domain_overview_form(&$form, &$form_state) {
  global $user;
  //dpm($form);
  //dpm($form_state);
  //dpm($form_state['node']);
  //dpm(current_path());
  if (!user_access('administer domains')) {
    $no_domains = TRUE;
    foreach ($form['domain'] as $key => $info) {
      if (is_array($info) && array_key_exists('values', $info)) {
        $domain = $info['values']['#value'];
        if (!array_key_exists($domain['domain_id'], $user->domain_user)) {
          unset($form['domain'][$key]);
          unset($form['domain_actions'][$key]);
          unset($form['default_domain']['#options'][$key]);
        }
        else {
          $no_domains = FALSE;
        }
      }
    }
    // If the user cannot change the default domain,
    // clear the submit button.
    unset ($form['submit']);
    if ($no_domains) {
      $form['top']['#markup'] = t('You have no domains that you can edit.');
    }
  }
}

function wk_form_alter__domain_form(&$form, &$form_state) {
  if (!user_access('administer domains')) {
    foreach ($form as $key => $info) {
      if (is_array($info) && (array_key_exists('#type', $info))) {
        $form[$key]['#disabled'] = TRUE;
      }
    }
  }
}

function wk_form_alter__domain_theme_form(&$form, &$form_state) {
  if (!user_access('administer domains') && !user_access('administer themes for assigned domains')) {
    $form['submit']['#disabled'] = TRUE;
    $form['intro'] = array('#markup' => t('You do not have permission to change the theme for this domain, but you may configure the theme settings for the selected theme.'));
    foreach ($form['theme'] as $id => $info) {
      if (isset($info['#type']) && ($info['#type'] == 'radio')) {
        if (!$form['theme'][$id]['#default_value']) {
          unset($form['theme'][$id]);
        }
        else {
          $form['theme'][$id]['#disabled'] = TRUE;
        }
      }
    }
  }
}

/**
 * Implementation of hook_block_info().
 */
function wk_block_info() {
  $blocks['wk_related_sites'] = array(
    'info' => t('Related Sites'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/*
  $site_label = wk_branch_site_label($branch_term);
  $description = strip_tags($branch_term['description']);
  $site_label .= " <span class='site-label-location'>$description</span>";
*/

/**
 * Implementation of hook_block_view().
 */
function wk_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'wk_related_sites':
      $content = '';
      $parent_terms = regnum_domain_parent_term_list();
      if (!empty($parent_terms)) {
        $parent_term_list = wk_branch_site_label_list(array_reverse($parent_terms), array("class" => "site-arms"));
        $parent_list_html = theme_item_list(array('items' => $parent_term_list, 'title' => NULL, 'type' => 'ul', 'attributes' => array()));
        $content = "<span id='parent-sites'>$parent_list_html</span>";
      }
      $site_branch_term = regnum_domain_taxonomy_term();
      $children_terms =  taxonomy_get_children($site_branch_term->tid);
      if (!empty($children_terms)) {
        $children_terms_list = wk_branch_site_label_list($children_terms, array("class" => "site-arms"));
        $children_list_html = theme_item_list(array('items' => $children_terms_list, 'title' => FALSE, 'type' => 'ul', 'attributes' => array()));
        $content .= "<span id='parent-sites'>$children_list_html</span>";
      }
      $block['subject'] = t('Related Sites');
      $block['content'] = $content;
      break;
  }
  return $block;
}

/**
 * Don't allow users to change their personal email address
 * on contact forms.  This validate function will only be set
 * if the user was logged in; anonymous users get to put whatever
 * they want here.
 */
function _wk_form_validate_email_not_changed($form, &$form_state) {
  global $user;
  if ($form_state['values']['mail'] != $user->mail) {
    form_error($form, t('You may not change your email address on the contact form.'));
  }
}

/**
 * Implements hook_block_view_alter
 */
function wk_block_view_alter(&$data, $block) {
  // The officers list block 1 is a view that shows
  // the list of officers in a given office.  The view
  // is configured to show on nodes in a group; however,
  // we only want it to display on the top-level group
  // node.  Therefore, we test explicitly for node type
  // of 'officers', and remove the block for all other
  // node types.
  if ($block->delta == "officers_list-block_1") {
    $node = menu_get_object();
    if ($node && $node->type != 'officers') {
      $data['content'] = FALSE;
    }
  }
  /*
  // Example from drupal.org documentation:
  // Add a theme wrapper function defined by the current module to all blocks
  // provided by the "somemodule" module.
  if (is_array($data['content']) && $block->module == 'somemodule') {
    $data['content']['#theme_wrappers'][] = 'mymodule_special_block';
  }
  */
}

/*
// not working; leaving here to try again later
function wk_admin_menu_output_alter(&$content) {
  $node = menu_get_object();
  if ($node) {
    $content['menu']['node/add']['node/add/page']['#options']['query'] = array('og_group_ref' => $node->nid);
  }
  //var_export($content);
}
*/

/**
 * Implement hook_domain_conf()
 */
function wk_domain_conf() {
  $form['wk'] = array(
    '#type' => 'fieldset',
    '#title' => t('Copyright'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['wk']['wk_copyright_base_year'] = array(
    '#type' => 'textfield',
    '#title' => t('Site copyright base year'),
    '#default_value' => variable_get('wk_copyright_base_year', ''),
    '#size' => 30,
    '#maxlength' => 255,
    '#description' => t('The first year that material was placed on this site. The token [site:copyright] will result in a range of years spanning from the base year to the current year (e.g. 2010-2013).')
  );
  return $form;
}

/**
 * Implements hook_permission().
 */
function wk_permission() {
  $permissions = array(
    'approve calendar requests' => array(
      'title' => t('Approve calendar date requests'),
    ),
    'configure calendar requests' => array(
      'title' => t('Configure settings for calendar date requests'),
    ),
    'administer site configuration for assigned domains' => array(
      'title' => t('Administer site configuration for assigned domains'),
      'restrict access' => TRUE,
    ),
    'administer menu for assigned domains' => array(
      'title' => t('Administer menu for assigned domains'),
    ),
    'administer themes for assigned domains' => array(
      'title' => t('Administer themes for assigned domains'),
      'description' => t('Select the theme for assigned domains, and adjust theme configuration.'),
    ),
    'administer theme configuration for assigned domains' => array(
      'title' => t('Administer theme configuration for assigned domains'),
      'description' => t("Allow a user who cannot change the domain theme to configure the selected theme's configuration."),
    ),
  );
  return $permissions;
}

/**
 * Implements hook_menu
 */
function wk_menu() {
  $items = array();

  $items['officers/%'] = array(
    'title' => 'Officer List',
    'description' => 'Show all of the officers for a specified branch group.',
    'page callback' => 'wk_officer_list',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['approve-date-requests'] = array(
    'title' => 'Approve Calendar Date Requests',
    'description' => 'Approve or deny all submitted calendar date requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_date_request_multiple_approval_form'),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['approve-date-request/%'] = array(
    'title' => 'Approve Calendar Date Request',
    'description' => 'Approve or deny a specific submitted calendar date requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_date_request_approval_form', 1),
    'access callback' => 'wk_user_access_or_group_member',
    'access arguments' => array('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID)),
  );
  $items['calendar-status'] = array(
    'title' => 'Calendar Status',
    'description' => 'Show whether the calendar is open for new date requests',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_calendar_status'),
    'access callback' => TRUE,
  );
  $items['admin/config/calendar-requests'] = array(
    'title' => 'Calendar Status Settings',
    'description' => 'Configure calendar date request settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wk_calendar_request_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('configure calendar requests'),
  );
  return $items;
}

function wk_calendar_request_settings($form, &$form_state) {
  $activity_tree = taxonomy_get_tree(4);
  $form += _wk_calendar_request_settings_subtree($activity_tree, 0);
  $form['save'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#submit' => array('_wk_save_calendar_request_settings'),
  );

  return $form;
}

function _wk_save_calendar_request_settings($form, &$form_state) {
  $new_settings = array();
  foreach ($form_state['values'] as $id => $value) {
    // Handle the 'k-###' and 'p-###' checkboxes
    if ($id[1] == '-') {
      if ($value) {
        $kind = $id[0];
        $tid = substr($id, 2);
        $new_settings[$kind][$tid] = $tid;
      }
    }
  }
  variable_set('wk-calendar-request-settings', $new_settings);
}

function _wk_calendar_request_settings_subtree($activity_tree, $parent, $level = 0) {
  $items = array();
  $calendar_request_settings = _wk_calendar_request_get_settings();
  foreach ($activity_tree as $index => $item) {
    if (in_array($parent, $item->parents)) {

      $items['k-' . $item->tid] = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('kingdom-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['k'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['k'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "",
      );
      $items['p-' . $item->tid] = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('principality-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['p'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['p'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "",
      );
      $items['x-' . $item->tid] = array(
        '#title' => str_pad('', $level * 18, '&nbsp;', STR_PAD_LEFT) . $item->name,
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('other-kingdoms-cal-req-setting')),
        '#checked' => isset($calendar_request_settings['x'][$item->tid]),
        '#default_value' => isset($calendar_request_settings['x'][$item->tid]),
        '#prefix' => "",
        '#suffix' => "<div class='after-cal-req-setting'></div>",
      );
      $items += _wk_calendar_request_settings_subtree($activity_tree, $item->tid, $level + 1);
    }
  }
  return $items;
}

function _wk_calendar_request_get_settings() {
  return variable_get('wk-calendar-request-settings',
    array(
      /*
      'k' => array(141 => 141),
      'p' => array(141 => 141),
      'x' => array(141 => 141),
      */
    ));
}

function _wk_get_calendar_event_nids($year, $branch = FALSE) {
  $start_date = $year . '-01-01T00:00:00';
  $end_date = $year + 1 . '-01-01T00:00:00';
  return _wk_get_calendar_event_nids_in_range($start_date, $end_date, $branch);
}

function _wk_get_calendar_event_nids_in_range($start_date, $end_date, $branch = FALSE) {
  $nids = array();
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('cal_event'))
    ->propertyCondition('status', 1)
    ->fieldCondition('field_event_type', 'value', 0, '=')
    ->fieldCondition('field_date', 'value', $start_date, '>')
    ->fieldCondition('field_date', 'value', $end_date, '<')
    ->fieldOrderBy('field_date', 'value');
  if ($branch) {
    if (is_array($branch)) {
      $query = $query->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, 'IN');
    }
    else {
      $query = $query->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
    }
  }

  $entities = $query->execute();

  if (!empty($entities)) {
    $nids = array_keys($entities['node']);
  }
  return $nids;
}

function wk_user_access_or_group_member($permission, $group_list) {
  if (user_access($permission)) {
    return TRUE;
  }
  foreach ($group_list as $gid) {
    if (og_is_member('node', $gid)) {
      return TRUE;
    }
  }
  return FALSE;
}

// Return the list of nodes that should go on next year's
// calendar during the initial planning phase, prior to opening
// the calendar to branch groups.
function wk_events_for_next_years_calendar($year) {
  $result = array();
  $principalities = wk_children_of_branch_tids(KINGDOM_OF_THE_WEST_TID);
  $other_kingdoms = wk_children_of_branch_tids(SOCIETY_TID);
  $event_nids = _wk_get_calendar_event_nids($year, array_merge(array(KINGDOM_OF_THE_WEST_TID), $principalities, $other_kingdoms));
  return wk_load_nodes($event_nids);
}

// What year is already open for all events?
function wk_calendar_year_open_for_all_events() {
  $result = 0;

  // If there is no information about the status of the calendar, or if
  // it is out of date, then the calendar will automatically open for all
  // events on the first day of that year.  This is the "default year",
  // and we will never return a result less than this.
  $default_year = date("Y");
  // The calendar will open for all events on a certain date and time;
  // if the current date and time is past this milestone, then the calendar
  // is open for all events for the year AFTER the time and date the
  // milestone occurred in.
  $open_for_all_milestone = variable_get('calendar-open-for-all', 0);
  if ($open_for_all_milestone) {
    if (time() > $open_for_all_milestone) {
      $result = date("Y", $open_for_all_milestone) + 1;
    }
  }
  return max($default_year, $result);
}

function wk_calendar_year_of_preparation() {
  $open_year = wk_calendar_year_open_for_all_events();
  switch (wk_calendar_status_for_next_year()) {
    case CALENDAR_STATUS_CLOSED:
      return $open_year;
    case CALENDAR_STATUS_PREPARING:
    case CALENDAR_STATUS_ONE_EVENT:
    case CALENDAR_STATUS_TWO_EVENTS:
      return $open_year + 1;
  }
}

// What is the status for the calendar year that comes after
// the year returned by wk_calendar_year_open_for_all_events?
//
// CLOSED - no one can make any calendar date requests for next year.
//
// PREPARING - like closed, most groups cannot make date requests for
// next year.  During this phase, the Kingdom Seneschal and Calendar
// deputy place the required events for the Kingdom on the calendar.
//
// ONE EVENT - every branch group may request a single event.  This is
// in addition to any required events already on the calendar (i.e. for
// principalities).
//
// After the ONE EVENT phase, the calendar opens for all events -- by
// bumping wk_calendar_year_open_for_all_events() by one year, and
// reseting to CLOSED for the next year.
function wk_calendar_status_for_next_year() {
  $result = CALENDAR_STATUS_CLOSED;
  $open_for_all_milestone = variable_get('calendar-open-for-all', 0);
  $preparing_milestone = variable_get('calendar-preparing', 0);
  $open_one_event_milestone = variable_get('calendar-open-for-one', 0);
  $open_two_events_milestone = variable_get('calendar-open-for-two', 0);

  if (($preparing_milestone > $open_for_all_milestone) && (time() > $preparing_milestone)) {
    $result = CALENDAR_STATUS_PREPARING;
  }

  if (($open_one_event_milestone > $open_for_all_milestone) && (time() > $open_one_event_milestone)) {
    $result = CALENDAR_STATUS_ONE_EVENT;
  }
  if (($open_two_events_milestone > $open_for_all_milestone) && (time() > $open_two_events_milestone)) {
    $result = CALENDAR_STATUS_TWO_EVENTS;
  }

  return $result;
}

function wk_calendar_status($form, &$form_state) {
  $status_messages = array(
    CALENDAR_STATUS_CLOSED => t("Not open yet."),
    CALENDAR_STATUS_PREPARING => t("Preparing to open."),
    CALENDAR_STATUS_ONE_EVENT => t("Open for one event request per group."),
    CALENDAR_STATUS_TWO_EVENTS => t("Open for up to two event requests per group."),
  );
  $open_year = wk_calendar_year_open_for_all_events();
  $next_years_status = wk_calendar_status_for_next_year();
  $this_year = date("Y");
  $form['status-summary'] = array(
    '#markup' => t('<p><b>Calendar status for !open_year:</b> Open for all events.</p>', array('!open_year' => $open_year, '!next_year' => $open_year + 1, '!msg' => $status_messages[$next_years_status])),
  );
  if ($open_year == $this_year) {
    $form['next-year-summary'] = array(
      '#markup' => t('<p><b>Calendar status for !next_year:</b> !msg</p>', array('!open_year' => $open_year, '!next_year' => $open_year + 1, '!msg' => $status_messages[$next_years_status])),
    );
  }
  $fn = 'wk_calendar_status_' . strtolower($next_years_status);
  return $fn($form, $form_state);
}

function wk_calendar_status_closed($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $this_year = date("Y");
  // TODO:  do not display this message until 'next_year' is nearly upon us
  // (October and later, maybe?).  For now, we will display the message
  // for the full calendar year (from January), but we will not include
  // the message for calendar years more than one full year away.
  if ($open_year == $this_year) {
    $form['closed-message'] = array(
      '#markup' => t('<p>The calendar is CLOSED for requests in !next_year.  Usually, the Seneschal and Calendar Deputy begin to prepare the calendar in April.  Once the calendar is ready, it will be opened up for ONE event request for every branch group.</p>', array('!next_year' => $open_year + 1)),
    );
  }

  // Give Seneschals the chance to pick an event from last year to hold again this year.
  $form = wk_calendar_events_for_one_branch($form, $form_state, UNLIMITED);

  // Add control for web administrator to begin calendar preparation
  return wk_calendar_events_for_calendar_preparation($form, $form_state);
}

function wk_calendar_status_preparing($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['preparing-message'] = array(
    '#markup' => t('<p>The calendar is CLOSED for requests in !next_year.  The Seneschal and Calendar Deputy are currently preparing the calendar for next year.  Once it is ready, it will be opened up for ONE event request for every branch group.</p>', array('!next_year' => $open_year + 1)),
  );
  if(wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID))) {
    $form['open-for-one'] = array(
      '#type' => 'submit',
      '#value' => t('Open For One Event'),
      '#submit' => array('_wk_open_calendar_for_one_date_request'),
    );
    $form = wk_calendar_events_for_calendar_preparation($form, $form_state);
  }
  return $form;
}

function wk_calendar_status_one_event($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['preparing-message'] = array(
    '#markup' => '<p>' . t('The calendar is open for ONE event request for each branch group in !next_year.', array('!next_year' => $open_year + 1)) . '</p>',
  );
  if(wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID))) {
    $form['open-for-all'] = array(
      '#type' => 'submit',
      '#value' => t('Open For TWO Events'),
      '#submit' => array('_wk_open_calendar_for_two_date_request'),
    );
  }
  return wk_calendar_events_for_one_branch($form, $form_state, 1);
}

function wk_calendar_status_two_events($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $form['preparing-message'] = array(
    '#markup' => '<p>' . t('The calendar is open for UP TO TWO event requests for each branch group in !next_year.', array('!next_year' => $open_year + 1)) . '</p>',
  );
  if(wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID))) {
    $form['open-for-all'] = array(
      '#type' => 'submit',
      '#value' => t('Open For All Events'),
      '#submit' => array('_wk_open_calendar_for_all_requests'),
    );
  }
  return wk_calendar_events_for_one_branch($form, $form_state, 2);
}

function wk_calendar_events_for_one_branch($form, &$form_state, $event_limit = UNLIMITED) {
  // Determine if current user is the Seneschal of a group.
  $branch_groups = _wk_is_seneschal();
  if (!empty($branch_groups)) {
    $year = wk_calendar_year_of_preparation();
    $event_nids = _wk_get_calendar_event_nids($year - 1, $branch_groups);
    $events = wk_load_nodes($event_nids);
    if (!empty($events)) {
      $selectable_items = array();
      $unselectable_items = array();
      $existing_date_request_count = 0;
      foreach ($events as $nid => $node) {
        // TODO: what if the group requested an event not held last year?  We still need
        // to record that as their selection.
        $date_request_info = _wk_find_date_request_for_event($nid);
        if ($date_request_info) {
          $existing_date_request_count++;
          $list = array_keys($date_request_info);
          $entityform_id = reset($list);
          $date_request_entity = entityform_load($entityform_id);
          $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);


          // TODO: This needs to go somewhere other than the date approval page.
          $url = 'entityform/' .  $date_request->entityform_id->value() . '/edit';
          $approved_event_node = $date_request->field_approved_event->value();
          if (!empty($approved_event_node)) {
            //$approved_node = entity_metadata_wrapper('node',$approved_event_node);
            //$approved_date = $approved_node->field_date->value();
            // TODO: link to the event listing
            //$checkbox['#title'] .= ' ' . t("Approved for !when", array('!when' => l(_wk_format_date($approved_date[0], 'Y F d'), 'node/' . $approved_event_node->nid)));

            $url = 'node/' . $approved_event_node->nid;
          }
          //else {
          //  $requested_date = $date_request->field_first_choice_date->value();
          //  $checkbox['#title'] .= ' ' . t("Requested for !when", array('!when' => l(_wk_format_date($requested_date, 'Y F d'), $url)));
          //}




          $unselectable_items[$nid] = '<b>' . l($node->title, $url) . '</b>';
          $selectable_items[$nid] = $unselectable_items[$nid];
        }
        else {
          $unselectable_items[$nid] = '<i>' . $node->title . '</i>';
          $selectable_items[$nid] = l($node->title, 'calendar-date-request/' . $nid);
        }
      }
      // If only one event is allowed, and one or more dates have been requested,
      // then tell the Seneschal to wait until the calendar opens for all events.
      if ($existing_date_request_count >= $event_limit) {
        if ($event_limit == 1) {
          $limit_msg = t('You have already requested a calendar date for an event in this calendar period.  You must wait until the calendar is opened for a second event for each group before you request another.');
        }
        else {
          $limit_msg = t('You have already requested your limit of !n events in this calendar period.  You must wait until the calendar is opened for all events before you request another.', array('!n' => $existing_date_request_count));
        }
        $form['already-selected-message'] = array(
          '#markup' => t('<p>!limit<ul><li>!events</li></ul></p>', array('!events' => implode('</li><li>', $unselectable_items), '!limit' => $limit_msg)),
        );
      }
      else {
        $exising = '';
        if ($existing_date_request_count > 0) {
          $existing = t('Events in bold type have already been requested.');
        }
        if ($event_limit >= UNLIMITED) {
          $form['pick-one-message'] = array(
            '#markup' => t('<p>Click on the events below in turn to request new dates to hold them again next year. !existing<ul><li>!events</li></ul></p>', array('!events' => implode('</li><li>', $selectable_items), '!existing' => $existing)),
          );
        }
        else {
          $form['pick-one-message'] = array(
            '#markup' => t('<p>Pick an event to hold again next year. !existing<ul><li>!events</li></ul></p>', array('!events' => implode('</li><li>', $selectable_items), '!existing' => $existing)),
          );
        }
        // Also include a link to the calendar date request form
        $form['calendar-date-request-form'] = array(
          '#markup' => t('<p>Use the !request_form to request a date for an event not shown above.</p>', array('!request_form' => l("calendar date request form", 'calendar-date-request'))),
        );
      }
    }
  }
  return $form;
}

function wk_calendar_events_for_calendar_preparation($form, &$form_state) {
  $open_year = wk_calendar_year_open_for_all_events();
  $this_year = date("Y");
  $next_year = $this_year + 1;

  // If the calendar is open for all events this year, and closed for next year,
  // then put in the controls to begin calendar planning for next year.  The
  // alternative is that the calendar is already open for all events next year;
  // in that case, it is too early to begin preparing the calendar for the year
  // after, so leave these controls off.
  if ($next_year > $open_year) {
    $next_years_status = wk_calendar_status_for_next_year();
    $editable = wk_user_access_or_group_member('approve calendar requests', array(KINGDOM_WEBMINISTER_GID, KINGDOM_SENESCHAL_GID));
    $events_for_next_year = wk_events_for_next_years_calendar($this_year);
    $non_carryover = array();
    foreach ($events_for_next_year as $nid => $node) {
      $carryover = FALSE;
      $kingdom_or_principality = _wk_kingdom_or_principality_event($node);
      if ($kingdom_or_principality && isset($node->field_activities[$node->language])) {
        foreach ($node->field_activities[$node->language] as $index => $tid_info) {
          $tid = $tid_info['tid'];
          if (_wk_is_carryover_activity($tid, $kingdom_or_principality)) {
            $carryover = TRUE;
          }
        }
      }
      $checkbox = array(
        '#type' => 'checkbox',
        '#attributes' => array('class' => array('carryover-selection')),
        '#checked' => $carryover,
        '#default_value' => $carryover,
        '#title' => l($node->title, 'node/' . $nid),
        '#disabled' => !$editable,
        '#prefix' => "",
        '#suffix' => "",
      );
      $date_request_info = _wk_find_date_request_for_event($nid);
      if ($date_request_info) {
        $list = array_keys($date_request_info);
        $entityform_id = reset($list);
        $date_request_entity = entityform_load($entityform_id);
        $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
        $url = 'approve-date-request/' .  $date_request->entityform_id->value();
        $approved_event_node = $date_request->field_approved_event->value();
        if (!empty($approved_event_node)) {
          $approved_node = entity_metadata_wrapper('node',$approved_event_node);
          $approved_date = $approved_node->field_date->value();
          // TODO: link to the event listing
          $checkbox['#title'] .= ' ' . t("Approved for !when", array('!when' => l(_wk_format_date($approved_date[0], 'Y F d'), 'node/' . $approved_event_node->nid)));
        }
        else {
          $requested_date = $date_request->field_first_choice_date->value();
          $checkbox['#title'] .= ' ' . t("Requested for !when", array('!when' => l(_wk_format_date($requested_date, 'Y F d'), $url)));
        }
      }
      if ($carryover) {
        $form['c-' . $nid] = $checkbox;
      }
      else {
        $non_carryover['c-' . $nid] = $checkbox;
      }
    }
    $form['non-carryover'] = array(
      '#type' => 'fieldset',
      '#title' => t('Other events'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    ) + $non_carryover;
    if ($editable) {
      $form['prepare_calendar'] = array(
        '#type' => 'submit',
        '#value' => $next_years_status == CALENDAR_STATUS_PREPARING ? t('Add Events') : t('Prepare Calendar'),
        '#submit' => array('_wk_prepare_calendar'),
      );
    }
  }
  return $form;
}

function _wk_open_calendar_for_one_date_request($form, &$form_state) {
  // TODO: check and see if there are calendar date requests for the
  // next year that have not been approved yet, and warn if so.
  // TODO: send email to all Seneschals informing them that they may
  // submit one calendar date request
  variable_set('calendar-open-for-one', time());
}

function _wk_open_calendar_for_two_date_request($form, &$form_state) {
  // TODO: check and see if there are calendar date requests for the
  // next year that have not been approved yet, and warn if so.
  // TODO: send email to all Seneschals informing them that they may
  // submit one calendar date request
  variable_set('calendar-open-for-two', time());
}

function _wk_open_calendar_for_all_requests($form, &$form_state) {
  // TODO: send email to all Seneschals informing them that they may
  // submit the rest of their calendar date requests
  variable_set('calendar-open-for-all', time());
}

function _wk_prepare_calendar($form, &$form_state) {
  $created_some_date_requests = FALSE;
  foreach ($form_state['values'] as $key => $value) {
    if (substr($key,0,2) == 'c-') {
      if ($value) {
        $nid = substr($key,2);
        $node = node_load($nid);
        wk_create_calendar_date_request($node);
        $created_some_date_requests = TRUE;
      }
    }
  }
  // Once some calendar date requests are created for the
  // coming year, we will consider that we have moved into
  // the PREPARING phase of the calendar date request process.
  if ($created_some_date_requests) {
    if (wk_calendar_status_for_next_year() == CALENDAR_STATUS_CLOSED) {
      variable_set('calendar-preparing', time());
    }
  }
  drupal_goto('approve-date-requests');
}

function _wk_expand_date_range_single_date($date_range, $date_to_add) {
  $result = $date_range;

  $date_epoch = _wk_format_date($date_to_add, "U");

  if (!isset($result['begin']) || ($result['begin'] > $date_epoch)) {
    $result['begin'] = $date_epoch;
  }

  if (!isset($result['end']) || ($result['end'] < $date_epoch)) {
    $result['end'] = $date_epoch;
  }

  return $result;
}

function _wk_expand_date_range($date_range, $date_to_add) {
  $date_range = _wk_expand_date_range_single_date($date_range, _wk_beginning_of_day($date_to_add));
  $date_range = _wk_expand_date_range_single_date($date_range, _wk_end_of_day(_wk_end_date($date_to_add)));
  return $date_range;
}

function _wk_expand_date_range_for_date_request($date_range, $date_request) {
  $date_range = _wk_expand_date_range($date_range, $date_request->field_first_choice_date->value());
  $date_range = _wk_expand_date_range($date_range, _wk_date_with_same_duration($date_request->field_alternate_date->value(), $date_request->field_first_choice_date->value()));
  $date_range = _wk_expand_date_range($date_range, _wk_date_with_same_duration($date_request->field_second_alternate_date->value(), $date_request->field_first_choice_date->value()));
  return $date_range;
}

function wk_date_request_multiple_approval_form($form, &$form_state) {
  $all_ids = _wk_date_request_all_ids();
  $date_requests = array();
  $date_range = array();
  foreach ($all_ids as $id => $info) {
    $date_request_entity = entityform_load($id);
    $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
    $date_requests[$id] = $date_request_entity;
    $date_range = _wk_expand_date_range_for_date_request($date_range, $date_request);
  }
  $other_approved_event_nids = _wk_get_calendar_event_nids_in_range(_wk_format_date($date_range['begin'], W3C_NoTZ), _wk_format_date($date_range['end'], W3C_NoTZ));
  $other_approved_events = wk_load_nodes($other_approved_event_nids);
  if (count($date_requests) == 1) {
    $title = $date_request->field_event_name->value();
    $form['event-title'] = array(
      '#markup' => "<h3>$title</h3>",
    );
    $form += _wk_date_request_approval_form_singular($form, $form_state, array_shift($date_requests), $other_approved_events);
  }
  else {
    foreach ($date_requests as $id => $date_request_entity) {
      //dpm($date_request_entity);
      $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
      $title = $date_request->field_event_name->value();
      $collapsed = FALSE;

      $approved_event_node = $date_request->field_approved_event->value();
      if (!empty($approved_event_node)) {
        $approved_node = entity_metadata_wrapper('node',$approved_event_node);
        $approved_date = $approved_node->field_date->value();
        $title .= t(' - APPROVED for !date', array('!date' => _wk_format_date($approved_date[0], 'Y F d')));
        $collapsed = TRUE;
      }
      $subform = _wk_date_request_approval_form_singular($form, $form_state, $date_request_entity, $other_approved_events, TRUE);
      $form['date_request_' . $id] = array(
        '#type' => 'fieldset',
        '#title' => $title,
        '#collapsible' => TRUE,
        '#collapsed' => $collapsed,
      ) + $subform;
    }
    $form['approve-checked'] = array(
      '#type' => 'submit',
      '#value' => t('Approve Checked Dates'),
      '#submit' => array('_wk_process_approve_checked_date_request'),
    );
  }
  return $form;
}

function wk_date_request_approval_form($form, &$form_state, $request_id) {
  $date_request_entity = entityform_load($request_id);
  $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);
  $date_range = _wk_expand_date_range_for_date_request(array(), $date_request);
  $other_approved_event_nids = _wk_get_calendar_event_nids_in_range(_wk_format_date($date_range['begin'], W3C_NoTZ), _wk_format_date($date_range['end'], W3C_NoTZ));
  $other_approved_events = wk_load_nodes($other_approved_event_nids);
  $title = $date_request->field_event_name->value();
  $form['event-title'] = array(
    '#markup' => "<h3>$title</h3>",
  );
  return $form + _wk_date_request_approval_form_singular($form, $form_state, $date_request_entity, $other_approved_events);
}

function _wk_render_branch_group($terms) {
  $result = "";
  $link_options = array();
  foreach ($terms as $term) {
    $e = entity_metadata_wrapper("taxonomy_term", $term);
    $img_info = $e->field_arms->value();
    if ($img_info) {
      $image_attributes = array('alt' => $term->name);
      $title = $term->name;
      $result .= "<div class='requesting-branch-group'>" . theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes)) . "<br>$title</div>";
    }
  }
  return $result;
}

function _wk_date_request_approval_form_singular($form, &$form_state, $date_request_entity, $other_approved_events, $include_checkboxes = FALSE) {
  global $user;
  $request_id = $date_request_entity->entityform_id;
  $date_request = new EntityDrupalWrapper('entityform', $date_request_entity);

  $approved_event_node = $date_request->field_approved_event->value();
  // If not approved, then put in the approval controls
  if (empty($approved_event_node)) {
    $subform['approval-options'] = array(
      '#type' => 'fieldset',
      '#attributes' => array('class' => array('approval-fieldset')),
    );
    $checkbox_options = array();
    $format_string = 'd F Y';
    $dv_first = $date_request->field_first_choice_date->value();
    $first_choice = _wk_format_date($dv_first, $format_string);
    $first_choice_text = _wk_format_date_range($dv_first, $format_string);
    $first_choice_epoch = _wk_format_date($dv_first, 'U');
    $conflicting_events = _wk_overlapping_events($other_approved_events, $dv_first);
    $subform['approval-options']['approve_first_choice_date_' . $request_id] = array(
      '#type' => 'submit',
      '#value' => t('Approve !d', array('!d' => $first_choice_text)),
      '#submit' => array('_wk_process_approve_date_request'),
      '#attributes' => array('date-request-id' => $request_id, 'date-choice' => 'field_first_choice_date'),
      '#prefix' => "<div class='approve-$request_id-$first_choice_epoch'>",
      '#suffix' => _wk_render_event_list($conflicting_events) . "</div>",
    );
    $checkbox_options[$first_choice_epoch] = $first_choice;
    $dv = _wk_date_with_same_duration($date_request->field_alternate_date->value(), $dv_first);
    $alternate_choice = _wk_format_date($dv, $format_string);
    $alternate_choice_text = _wk_format_date_range($dv, $format_string);
    $alternate_choice_epoch = _wk_format_date($dv, 'U');
    if (!empty($dv) && ($alternate_choice != $first_choice)) {
      $conflicting_events = _wk_overlapping_events($other_approved_events, $dv);
      $subform['approval-options']['approve_alternate_choice_button_' . $request_id] = array(
        '#type' => 'submit',
        '#value' => t('Approve !d', array('!d' => $alternate_choice_text)),
        '#submit' => array('_wk_process_approve_date_request'),
        '#attributes' => array('date-request-id' => $request_id, 'date-choice' => 'field_alternate_date'),
        '#prefix' => "<div class='approve-$request_id-$alternate_choice_epoch'>",
        '#suffix' => _wk_render_event_list($conflicting_events) . "</div>",
      );
      $checkbox_options[$alternate_choice_epoch] = $alternate_choice;
    }
    $dv = _wk_date_with_same_duration($date_request->field_second_alternate_date->value(), $dv_first);
    $second_alternate = _wk_format_date($dv, $format_string);
    $second_alternate_text = _wk_format_date_range($dv, $format_string);
    $second_alternate_epoch = _wk_format_date($dv, 'U');
    if (!empty($dv) && ($second_alternate != $first_choice) && ($second_alternate != $alternate_choice)) {
      $conflicting_events = _wk_overlapping_events($other_approved_events, $dv);
      $subform['approval-options']['approve_second_alternate_choice_button_' . $request_id] = array(
        '#type' => 'submit',
        '#value' => t('Approve !d', array('!d' => $second_alternate_text)),
        '#submit' => array('_wk_process_approve_date_request'),
        '#attributes' => array('date-request-id' => $request_id, 'date-choice' => 'field_second_alternate_date'),
        '#prefix' => "<div class='approve-$request_id-$second_alternate_epoch'>",
        '#suffix' => _wk_render_event_list($conflicting_events) . "</div>",
      );
      $checkbox_options[$second_alternate_epoch] = $second_alternate;
    }
    if ($include_checkboxes) {
      $subform['approval-options']['approve_checkboxes_' . $request_id] = array(
        '#type' => 'checkboxes',
        '#options' => $checkbox_options,
      );
      $subform['approval-options']['#post_render'] = array('_wk_approve_button_post_render');
    }
  }

  // Render the requesting branch group
  $subform['branch_group'] = array(
    '#markup' => _wk_render_branch_group($date_request->taxonomy_vocabulary_2->value()),
  );

  // Render the visible elements of the entityform
  $visible_elements = array(
    'info',
    'field_additional_information',
    'field_placeholder_event_descript',
  );
  $request_render_array = entityform_page_view($date_request_entity);
  foreach ($request_render_array['entityform'][$request_id] as $key => $info) {
    if (($key[0] != '#') && (!in_array($key, $visible_elements))) {
      hide($request_render_array['entityform'][$request_id][$key]);
    }
  }
  $subform['info_' . $request_id] = $request_render_array;

  // If not approved, then put in the contact and edit controls
  if (empty($approved_event_node)) {
    // If there is a Seneschal registered on this site,
    // put in a 'Contact' button that redirects to the
    // Seneschal's contact form.  Otherwise, put in
    // "mailto" link.
    $v = $date_request->taxonomy_vocabulary_2->value();
    if (!empty($v)) {
      $branch_group_tid = $v[0]->tid;
      $seneschal = _wk_get_officer($branch_group_tid, SENESCHAL_TID);
      if (count($v) > 1) {
        $alternate_branch_group_tid = $v[1]->tid;
        $alternate_seneschal = _wk_get_officer($alternate_branch_group_tid, SENESCHAL_TID);
        if ($alternate_seneschal && ($alternate_seneschal->mail == $date_request->field_email_address->value())) {
          $seneschal = $alternate_seneschal;
        }
      }

      // If we could not find the registered seneschal
      // of this branch group, then try to find any
      // user on the system who has the same email address
      // as the one entered on the form.
      if (!$seneschal) {
        $seneschal = _regnum_get_user(array('mail' => $date_request->field_email_address->value()));
      }

      // If you are the form submitter, or if you
      // are the Seneschal, then you do not need a
      // 'Contact' button.
      if (($user->mail != $date_request->field_email_address->value()) && ((!$seneschal) || ($user->mail != $seneschal->mail))) {
        if ($seneschal) {
          // 'Contact' button that leads to the contact
          // form of a regisered user.
          $subform['contact_' . $request_id] = array(
            '#type' => 'submit',
            '#value' => t('Contact !name', array('!name' => $seneschal->name)),
            '#submit' => array('_wk_process_contact_date_request'),
            '#attributes' => array('date-request-id' => $request_id, 'seneschal-uid' => $seneschal->uid),
          );
        }
        else {
          // A 'mailto' link pointing to whatever
          // email address was entered on the form.
          $subform['contact_' . $request_id] = array(
            '#markup' => '<span class="date-request-contact">' . l('Contact  ' . $date_request->field_society_name->value(), 'mailto://' . $date_request->field_email_address->value()) . '</span>',
          );
        }
      }
    }

    // 'Edit' button
    $subform['edit_' . $request_id] = array(
      '#type' => 'submit',
      '#value' => t('Edit'),
      '#submit' => array('_wk_process_edit_date_request'),
      '#attributes' => array('date-request-id' => $request_id),
    );
  }

  return $subform;
}

function _wk_process_contact_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  $seneschal_uid = $form_state['clicked_button']['#attributes']['seneschal-uid'];
  drupal_goto("user/$seneschal_uid/contact");
}

function _wk_process_edit_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  drupal_goto("entityform/$id/edit");
}

// Post-process the rendered HTML of our approval buttons and
// checkboxes to move the approval button next to the checkbox,
// repacing the checkbox's label.
function _wk_approve_button_post_render($content, $element) {
  // dpm($content);
  // Find all of the submit buttons
  if (preg_match_all("#<div class='approve-([0-9]*)-([0-9]*)'>[^<]*(<input[^>]*>.*)</div>#U", $content, $match_sets, PREG_SET_ORDER)) {
    // dpm($match_sets);
    foreach ($match_sets as $matches) {
      // For each submit button found, look for a corresponding
      // checkbox.  If a match is found, then replace the checkbox
      // label with the submit button.
      $matched_html = $matches[0];
      $matched_request_id = $matches[1];
      $matched_epoch = $matches[2];
      $matched_button_html = $matches[3];

      $content = str_replace($matched_html, '', $content);
      $content = preg_replace("#<label *class=\"option\" *for=\"edit-approve-checkboxes-$matched_request_id-$matched_epoch\">[^<]*</label>#", "<label class=\"option\" for=\"edit-approve-checkboxes-$matched_request_id-$matched_epoch\">$matched_button_html</label>", $content);
    }
  }
  return $content;
}

function _wk_format_date_range($dv, $format_string = 'd M Y') {
  $result = '';
  if (!empty($dv)) {
    $start = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    $end = new DateTime($dv['value2'], new DateTimeZone($dv['timezone']));
    // Different years?
    if ($start->format('Y') != $end->format('Y')) {
      $result = $start->format($format_string) . ' - ' . $end->format($format_string);
    }
    // Different months?
    elseif ($start->format('m') != $end->format('m')) {
      if (preg_match('/[dmM]+[^a-zA-Z]*[dmM]+/', $format_string, $matches)) {
        $adjusted_format = str_replace($matches[1], $start->format($matches[1]) . ' - ' . $matches[1], $format_string);
        $result = $end->format($adjusted_format);
      }
      else {
        $result = $start->format('d M') . ' - ' . $end->format('d M Y');
      }
    }
    // Different days?
    elseif ($start->format('d') != $end->format('d')) {
      $format_string = str_replace('d', 'd - ' . $end->format('d'), $format_string);
      $result = $start->format($format_string);
    }
    else {
      $result = $start->format($format_string);
    }
  }
  return $result;
}

function _wk_format_date($dv, $format_string = 'Y-m-d') {
  if (is_array($dv)) {
    if (!array_key_exists('value', $dv) || !array_key_exists('timezone', $dv)) {
      return "";
    }
    $d = new DateTime($dv['value'], new DateTimeZone($dv['timezone']));
    return $d->format($format_string);
  }
  else {
    return date($format_string, $dv);
  }
}

function _wk_format_end_date($dv, $format_string = 'Y-m-d')
{
  return _wk_format_date(_wk_end_date($dv), $format_string);
}

function _wk_end_date($dv) {
  if (is_array($dv) && array_key_exists('value2', $dv)) {
    $dv['value'] = $dv['value2'];
  }
  return $dv;
}

function _wk_beginning_of_day($dv) {
  if (is_array($dv)) {
    $dv['value'] = _wk_format_date($dv, Drupal_BeginningOfDay);
  }
  return $dv;
}

function _wk_end_of_day($dv) {
  if (is_array($dv)) {
    $dv['value'] = _wk_format_date($dv, Drupal_EndOfDay);
  }
  return $dv;
}

function _wk_date_with_same_duration($date_origin, $date_with_duration) {
  if (empty($date_origin)) {
    $result = $date_origin;
  }
  else {
    $result = $date_with_duration;
    $start_date = new DateTime($date_with_duration['value'], new DateTimeZone($date_with_duration['timezone']));
    $start_date->setTime(12,0,0);
    $end_date = new DateTime($date_with_duration['value2'], new DateTimeZone($date_with_duration['timezone']));
    $end_date->setTime(12,0,0);
    $duration = $start_date->diff($end_date);

    $working_date = new DateTime(_wk_format_date($date_origin, "Y-m-d") . ' 12:00:00', $start_date->getTimezone());
    $result['value'] = $working_date->format('Y-m-d') . ' 12:00:00';

    $working_date->add($duration);
    $result['value2'] = $working_date->format('Y-m-d') . ' 12:00:00';
  }

  return $result;
}

//
// Not overlapping, case 1:
//
// End date of date 1 is less than beginning date of date 2.
//
// (b1)---date 1---(e1)   (b2)---date 2---(e2)
//
// Not overlapping, case 2:
//
// End date of date 2 is less then beginning date of date 1.
//
//                        (b2)---date 2---(e2)   (b1)---date 1---(e1)
//
// Anything else is overlapping.
//
// Note also that anything that is on any part of the same day
// is considered to be overlapping; we will always compare from
// the beginning of the day of the begin date through the end of
// the day of the end date when doing comparisons, regardless of the
// actual times that the event might start and end.
//
function _wk_overlapping_dates($date_value1, $date_value2) {
  $b1 = _wk_format_date(_wk_beginning_of_day($date_value1), "U");
  $e1 = _wk_format_date(_wk_end_of_day(_wk_end_date($date_value1)), "U");
  $b2 = _wk_format_date(_wk_beginning_of_day($date_value2), "U");
  $e2 = _wk_format_date(_wk_end_of_day(_wk_end_date($date_value2)), "U");
  $not_overlapping = ($e1 < $b2) || ($e2 < $b1);
  // Ugh, the double-negative.
  return !$not_overlapping;
}

function _wk_overlapping_events($list_of_events, $date_value) {
  $result = array();

  foreach($list_of_events as $nid => $node) {
    if (_wk_overlapping_dates($node->field_date[$node->language][0], $date_value)) {
      $result[$nid] = $node;
    }
  }

  return $result;
}

// Handle 'Approved Selected Dates' button.
function _wk_process_approve_checked_date_request($form, &$form_state) {
  // Iterate over all of the checked buttons
  // Make sure that each event has at most one checked date
  $approval_list = array();
  foreach ($form_state['values'] as $key => $info) {
    if (substr($key, 0, 19) == 'approve_checkboxes_') {
      $id = substr($key, 19);
      $selected = FALSE;
      foreach ($info as $value => $state) {
        if ($state) {
          // TODO: if $selected is TRUE, that means two dates
          // were approved.  We should error out, but for now
          // we will instead assume first-selected wins.
          if (!$selected) {
            $selected = $value;
          }
        }
      }
      if ($selected) {
        $approval_list[$id] = $selected;
      }
    }
  }

  if (empty($approval_list)) {
    drupal_set_message(t("You must select at lease one date before clicking the 'Approve Checked Dates' button."), 'error');
  }
  else {
    // Call _wk_approve_selected_date_request for each selected event
    $nodes = array();
    foreach ($approval_list as $id => $selected_date) {
      $node = _wk_approve_selected_date_request($id, $selected_date);
      if ($node) {
        $nodes[$node->nid] = $node;
      }
    }
    // TODO: show summary of approved events
    // drupal_goto("calendar-date-request");
  }
}

// Handle 'Approve (single date)' button
function _wk_process_approve_date_request($form, &$form_state) {
  $id = $form_state['clicked_button']['#attributes']['date-request-id'];
  $choice = $form_state['clicked_button']['#attributes']['date-choice'];
  $date_request = new EntityDrupalWrapper('entityform', $id);
  $selected_date = _wk_format_date($date_request->$choice->value(), "U");
  $node = _wk_approve_selected_date_request($id, $selected_date);
  drupal_goto("node/" . $node->nid);
}

function _wk_approve_selected_date_request($id, $selected_date) {
  $date_request = new EntityDrupalWrapper('entityform', $id);
  // Calculate correct event date by looking at the
  // duration of the first choice date, and adding it
  // to 'selected_date'.
  $event_date = _wk_date_with_same_duration($selected_date, $date_request->field_first_choice_date->value());

  $node = new stdClass();
  $node->type = 'cal_event';
  node_object_prepare($node);
  $node->title = $date_request->field_event_name->value();
  $node->language = LANGUAGE_NONE;

  $v = $date_request->taxonomy_vocabulary_2->value();
  if (!empty($v)) {
    $branch_group_tid = $v[0]->tid;

    $node->taxonomy_vocabulary_2[$node->language][] = array('tid' => $branch_group_tid);
  }

  // TODO: Better way to build this record?
  $node->field_date[$node->language][0] = array(
    'value' => _wk_format_date($event_date, 'Y-m-d') . "T12:00:00",
    'value2' => _wk_format_date(_wk_end_date($event_date), 'Y-m-d') . "T22:00:00",
    'offset' => -25200,
    'offset2' => -25200,
    'timezone' => "America/Los_Angeles",
    'date_type' => 'date',
  );

  $body = t("More information will be posted as it becomes available.");
  $seneschal = _wk_get_officer($branch_group_tid, SENESCHAL_TID);
  if ($seneschal) {
    $body = t("<b>Autocrat:</b> <a href='!uri'>!name</a><br><br>", array('!uri' => 'user/' . $seneschal->uid . '/contact', '!name' => $seneschal->name)) . $body;
    $node->uid = $seneschal->uid;
  }
  $node->body[$node->language][] = array(
    'value' => $body,
    'format' => '1',
  );
  $node->revision_moderation = FALSE;
  $node->is_pending = FALSE;
  $node->status = TRUE;
  // If this is a repeat of some previous event, copy over
  // certain activities.
  $repeat_of_node = $date_request->field_repeat_of_event->value();
  if ($repeat_of_node && isset($repeat_of_node->field_activities[$repeat_of_node->language])) {
    $kingdom_or_principality = _wk_kingdom_or_principality_event($repeat_of_node);
    if ($kingdom_or_principality) {
      $carryover_activities = array();
      foreach ($repeat_of_node->field_activities[$repeat_of_node->language] as $index => $tid_info) {
        $tid = $tid_info['tid'];
        if (_wk_is_carryover_activity($tid, $kingdom_or_principality)) {
          $carryover_activities[] = $tid_info;
        }
      }
    }
    $node->field_activities[$node->language] = $carryover_activities;
  }
  node_save($node);

  // Mark date request as approved
  $date_request->field_approved_event->set($node->nid);
  $date_request->save();

  // Save an unpublished revision containing the requested event text
  if (module_exists('revisioning')) {
    $requested_event_description = $date_request->field_placeholder_event_descript->value();
    if (!empty($requested_event_description)) {
      $node->revision_operation = 2; // new revision with moderation
      $node->body[$node->language][0]['value'] = $requested_event_description;
      node_save($node);
    }
  }

  return $node;
}

// TODO:  How do we decide if an activity is a carryover activity
// or not?  A crown will always be a crown, and a coronation will
// always be a coronation, but other than that...
// For now, this is only called for Kingdom and Principality events;
// local events never have any carryover activities.  Also, the only
// activities that we carry over are those that are used in selecting
// the event as one that is added to the calendar during the planning
// phase in April.  All other activities must be re-selected each year.
function _wk_is_carryover_activity($tid, $kingdom_or_principality) {
  $activity_settings = _wk_calendar_request_get_settings();
  return array_key_exists($tid, $activity_settings[$kingdom_or_principality]);
}

// Given an array of nids, return an array of nid => node.
function wk_load_nodes($node_list) {
  $result = array();
  foreach ($node_list as $nid) {
    $result[$nid] = node_load($nid);
  }
  return $result;
}

function wk_children_of_branch_tids($parent_tid) {
  $branch_group_tree = taxonomy_get_tree(2);
  $result = array();
  foreach ($branch_group_tree as $term) {
    if (in_array($parent_tid, $term->parents)) {
      $result[$term->tid] = $term->tid;
    }
  }
  return $result;
}

// Return 'k' for Kingdom, 'p' for Principality, or FALSE.
function _wk_kingdom_or_principality_event($node) {
  $principalities = wk_children_of_branch_tids(KINGDOM_OF_THE_WEST_TID);
  $other_kingdoms = wk_children_of_branch_tids(SOCIETY_TID);
  $branch_info = $node->taxonomy_vocabulary_2[$node->language];
  $result = FALSE;

  foreach ($branch_info as $index => $tid_info) {
    $tid = $tid_info['tid'];
    if ($tid == KINGDOM_OF_THE_WEST_TID) {
      $result = 'k';
    }
    elseif (in_array($tid, $other_kingdoms)) {
      $result = 'x';
    }
    elseif (in_array($tid, $principalities)) {
      $result = 'p';
    }
    else {
      return FALSE;
    }
  }

  return $result;
}

function _wk_is_seneschal($the_user = NULL) {
  return _wk_is_officer(SENESCHAL_TID, $the_user);
}

// If the current user is a Seneschal, return
// the branch group tid
function _wk_is_officer($officer_tid, $the_user = NULL) {
  global $user;
  $result = array();
  if (!$the_user) {
    $the_user = $user;
  }
  $users_groups = og_get_entity_groups("user", $the_user);
  if (array_key_exists('node', $users_groups)) {
    foreach ($users_groups['node'] as $key => $nid) {
      $node = node_load($nid);
      $officer_page = new EntityDrupalWrapper('node', $node);
      foreach ($officer_page->field_office->value() as $term) {
        if ($term->tid == $officer_tid) {
          $branches = $officer_page->taxonomy_vocabulary_2->value();
          if (!empty($branches)) {
            $result[] = $branches[0]->tid;
          }
        }
      }
    }
  }
  return $result;
}

function _wk_get_officer($branch, $office) {
  $user_info = FALSE;
  $node = _wk_get_officer_node($branch, $office);
  if ($node) {
    $user_info = user_load($node->uid);
  }
  return $user_info;
}

function _wk_get_officer_node($branch, $office) {
  // $field_map = array(
  //    'office' => 'field_office',
  //    'branch' => 'taxonomy_vocabulary_2',
  //  )
  $field_map = _regnum_group_field_map("regnum_change", "officers");
  return _regnum_get_officer_node('officers', $field_map, array('branch' => $branch, 'office' => $office));
}

// Return all calendar date requests
function _wk_date_request_all_ids() {
  $date_requests = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', "entityform");
  $query->propertyCondition('type', 'calendar_date_request');
  $result = $query->execute();
  if (isset($result['entityform'])) {
    $date_requests = $result['entityform'];
  }
  return $date_requests;
}

// Find the specific calendar date request to re-hold the specified
// event again the following year.
function _wk_find_date_request_for_event($nid) {
  $date_requests = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', "entityform");
  $query->propertyCondition('type', 'calendar_date_request');
  $query->fieldCondition('field_repeat_of_event', 'nid', $nid, '=');
  $result = $query->execute();
  if (isset($result['entityform'])) {
    $date_requests = $result['entityform'];
  }
  return $date_requests;
}

function wk_menu_alter(&$items) {
  $items['admin/structure/domain']['access callback'] = '_wk_domain_view_access_callback';
  $items['admin/structure/domain']['access arguments'] = array('administer site configuration for assigned domains');
  $items['admin/structure/domain/view']['access callback'] = '_wk_domain_view_access_callback';
  $items['admin/structure/domain/view']['access arguments'] = array('administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/edit']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/edit']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/config']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/config']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/conf-reset']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/conf-reset']['access arguments'] = array(4, 'administer site configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/theme']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/theme']['access arguments'] = array(4, 'administer themes for assigned domains', 'administer theme configuration for assigned domains');
  $items['admin/structure/domain/view/%domain/theme/%/theme-settings']['access callback'] = '_wk_domain_conf_access_callback';
  $items['admin/structure/domain/view/%domain/theme/%/theme-settings']['access arguments'] = array(4, 'administer themes for assigned domains', 'administer theme configuration for assigned domains');
}

function _wk_domain_view_access_callback($permission) {
  return user_access('administer domains') || user_access($permission);
}

function _wk_domain_conf_access_callback($domain, $permission, $alternate_permission = '') {
  if (user_access('administer domains')) {
    return TRUE;
  }
  // If the user is assigned to this domain, then allow them to
  // edit this domain configuration item if they have the right
  // to do so, as granted by our permission
  global $user;
  if (array_key_exists($domain['domain_id'], $user->domain_user)) {
    return user_access($permission) || (!empty($alternate_permission) && user_access($alternate_permission));
  }
  return FALSE;
}

/**
 * Hook token_info
 *
 * Declare tokens as_year and event_month.
 */
function wk_token_info() {
  // These tokens are only available for nodes of type 'cal_event'
  $node['as_year'] = array(
    'name' => t("Anno Societatis Year"),
    'description' => t('Year in Anno Societatis (AS) notation. See http://www.sca.org/links/calendar.html.'),
  );
  $node['event_month'] = array(
    'name' => t("Event Month"),
    'description' => t('The month that the event is held in (reconed by starting date).'),
  );
  // Because of http://drupal.org/node/691078, we just hack in our own
  // field-based tokens here for now (cough).
  // These tokens are only available for nodes of type 'location' and
  // 'cal_event' (if the calendar event has a location set).
  $node['field_location_street'] = array(
    'name' => t("Location Street"),
    'description' => t('The street address that a location is located at.'),
  );
  $node['field_location_city'] = array(
    'name' => t("Location City"),
    'description' => t('The city that a location is in.'),
  );
  $node['field_location_province'] = array(
    'name' => t("Location Province"),
    'description' => t('The abbreviation for the province (State) that a location is in.'),
  );
  $node['field_location_province_name'] = array(
    'name' => t("Location Province Name"),
    'description' => t('The full name of the province (State) that a location is in.'),
  );
  $node['field_location_postal_code'] = array(
    'name' => t("Location Postal Code"),
    'description' => t('The postal code for the location.'),
  );
  $node['field_location_country'] = array(
    'name' => t("Location Country"),
    'description' => t('The country that a location is in.'),
  );
  $node['field_location_country_name'] = array(
    'name' => t("Location Country Name"),
    'description' => t('The full name of the country that a location is in.'),
  );
  $node['field_location_summary'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location (City, State).'),
  );
  $node['field_location_address'] = array(
    'name' => t("Location Summary"),
    'description' => t('A parenthesized summary of the location address (Street, City, State Zip).'),
  );
  $site['copyright'] = array(
    'name' => t("Copyright"),
    'description' => t("A range of years starting at the specified base year (as set in domain access settings) and continuing to the current year."),
  );
  $site['full-parentage'] = array(
    'name' => t("Full Parentage"),
    'description' => t("The full list of parent domains for the current domain within a site hierarchy."),
  );
  $date['as_year'] = array(
    'name' => t("AS year"),
    'description' => t("The date (year) in Anno Societatis (AS) notation. See http://www.sca.org/links/calendar.html."),
  );

  return array(
    'tokens' => array('node' => $node, 'site' => $site, 'date' => $date),
  );
}

/**
 * Hook tokens
 *
 * Provide data for as_year and event_month tokens.
 */
function wk_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'site') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'copyright':
          $date_info = getdate(time());
          $current_year = $date_info['year'];
          $base_year = variable_get('wk_copyright_base_year', '');
          if (($base_year == $current_year) || (empty($base_year))) {
            $copyright = $current_year;
          }
          else {
            $copyright = $base_year . '-' . $current_year;
          }
          $replacements[$original] = $copyright;
          break;

        case 'full-parentage':
          $replacements[$original] = _wk_full_parentage();
          break;
      }
    }
  }
  if ($type == 'date') {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'as_year':
          $the_date = time();
          $as = wk_timestamp_to_as($the_date);
          $replacements[$original] = 'AS' . $as;
          break;
      }
    }
  }
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    if ($node->type == 'cal_event') {
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'as_year':
            $start_date = $node->field_date['und'][0]['value'];
            $as = wk_time_string_to_as($start_date);
            $replacements[$original] = 'AS' . $as;
            break;
          case 'event_month':
            $start_date = $node->field_date['und'][0]['value'];
            $timestamp=strtotime($start_date);
            $replacements[$original] = date('M', $timestamp);
            break;
        }
      }
    }
    $location_field = array();
    if (($node->type == 'location') && (isset($node->field_location['und'][0]))) {
      $location_field = $node->field_location['und'][0];
    }
    if (($node->type == 'cal_event') && (isset($node->field_event_site['und'][0]))) {
      $location_nid = $node->field_event_site['und'][0]['nid'];
      $location_node = node_load($location_nid);
      if (isset($location_node->field_location['und'][0])) {
        $location_field = $location_node->field_location['und'][0];
      }
    }
    if (isset($location_field['city']) && isset($location_field['province'])) {
      $location_field['summary'] = "(" . $location_field['city'] . ", " . $location_field['province'] . ")";
    }
    else {
      $location_field['summary'] = '(TBD)';
    }
    $location_address = '';
    if (isset($location_field['street'])) {
      $location_address = str_replace(array_keys($location_field), array_values($location_field), "(street, city province postal_code)");
    }
    else {
      $location_address = '(TBD)';
    }
    $location_field['address'] = $location_address;
    foreach ($tokens as $name => $original) {
      if (substr($name,0,15) == 'field_location_') {
        // $name is always 'field_location_xxx', so key is 'xxx'.
        $key = substr($name, 15);
        if (isset($location_field[$key])) {
          $replacements[$original] = $location_field[$key];
        }
        else {
          $replacements[$original] = '';
        }
      }
    }
  }
  return $replacements;
}

function wk_render_node_field_date($node) {
  $render_array = wk_node_field_date_render_array($node);
  return drupal_render($render_array);
}

function wk_node_field_date_render_array($node) {
  $cal_event_date = array();
  if (isset($node->field_date[LANGUAGE_NONE][0]['rrule'])) {
    // Repeating events:  special checking for "weekly", then make our
    // own formatted string.  Question: could we do this with a date format?
    if (substr($node->field_date[LANGUAGE_NONE][0]['rrule'], 0, 28) == "RRULE:FREQ=WEEKLY;INTERVAL=1") {
      // See http://drupal.org/node/1108164 for other options.
      $date = new DateObject($node->field_date[LANGUAGE_NONE][0]['value'],'UTC',DATE_FORMAT_ISO);
      $cal_event_date = array('#markup' => '<div class="field-name-field-date">' . format_date($date->format('U'),'custom','\E\v\e\r\y l \a\t g:ia') . '</div>');
    }
  }
  else {
    // Non-repeating dates:  just use the default view mode, and print the
    // date with the format defined for 'field_date'.
    $cal_event_date = field_view_field('node', $node, 'field_date', 'default');
  }
  return $cal_event_date;
}

function wk_time_string_to_as($time_string) {
  $timestamp=strtotime($time_string);
  return wk_timestamp_to_as($timestamp);
}

function wk_timestamp_to_as($timestamp) {
  $date_info = getdate($timestamp);
  $as = $date_info['year'] - 1966;
  if ($date_info['mon'] >= 5) {
    $as = $as + 1;
  }
  return $as;
}

function wk_node_view($node, $view_mode, $langcode) {
  if (($node->type == 'cal_event') && ($view_mode == 'full')) {
    if (isset($node->content['field_event_site'][0]['body'])) {
      //$node->content['field_directions'] = $node->content['field_event_site'][0]['body'];
      if (!isset($node->content['field_directions'][0])) {
        $node->content['field_directions'] = array(
          '#theme' => 'field',
          '#weight' => 99,
          '#title' =>  'Directions',
          '#access' => TRUE,
          '#label_display' => 'above',
          '#view_mode' => 'full',
          '#language' => $langcode,
          '#field_name' => 'field_directions',
          '#field_type' => 'text',
          '#formatter' => 'text_default',
          '#entity_type' => 'node',
          '#bundle' => 'cal_event',
          '#object' => $node,
          '#items' => array(
            0 => array(
              'value' => '',
              'format' => NULL,
              'safe_value' => '')),
        );
      }
      $direction_diagram = '';
      if (isset($node->content['field_event_site'][0])) {
        $direction_diagram = render($node->content['field_event_site'][0]['field_directions_diagram']);
        hide($node->content['field_event_site'][0]['field_directions_diagram']);
      }
      $node->content['field_directions'][0]['#markup'] = $direction_diagram . $node->content['field_event_site'][0]['body'][0]['#markup'];
      hide($node->content['field_event_site'][0]['body']);
    }
  }
}

/**
 * Hook pathauto_alias alter.
 * See http://drupal.org/node/684132
 */
function wk_pathauto_alias_alter(&$alias, array &$context) {
  if (($context['op'] != 'return') && ($context['module'] == 'taxonomy_term')) {
    $term = $context['data']['term'];
    // Make calendar path aliases for branch group taxonomy terms (vid == 2)
    if ($term->vid == 2) {
      $short_name = _wk_term_short_name($term);
      $machine_name = _wk_to_machine_name($short_name);
      // Remap calendar/tid to calendar/term_name, etc.
      // This is like pathauto for view arguments.  :)
      $path_list = array(
        "calendar/%",
        "meetings/%"        => "meetings/%/0",
        "meetings/%/all"    => "meetings/%/9",
        "events/%"          => "events/%/0",
        "events/%/all"      => "events/%/9",
        "events/%/feed"     => "events/%/0/feed",
        "events/%/all/feed" => "events/%/9/feed",
      );
      foreach ($path_list as $alias_path => $system_path) {
        if (is_numeric($alias_path)) {
          $alias_path = $system_path;
        }
        $system_path = str_replace("%", $term->tid, $system_path);
        $alias_path = str_replace("%", $machine_name, $alias_path);
        $existing_path = path_load($system_path);
        if (!empty($existing_path)) {
          path_delete($existing_path['pid']);
        }
        if (!empty($alias_path)) {
          $path_args = array("source" => $system_path, "alias" => $alias_path);
          path_save($path_args);
        }
      }
    }
  }
}

function _wk_term_short_name($term) {
  $short_name = '';

  if (isset($term->field_short_name[LANGUAGE_NONE][0]['value'])) {
    $short_name = $term->field_short_name[LANGUAGE_NONE][0]['value'];
  }
  if (empty($short_name)) {
    $short_name = _wk_shorten_name($term->name);
  }

  return $short_name;
}

function _wk_shorten_name($name) {
  $remove = array("Kingdom of ", "Principality of ", "Palatine Barony of ", "Barony of ", "Kingdom of ", "Shire of ", "Province of ", "Canton of ", "College of ", "Stronghold of ", "the ", " (incipiant)");

  foreach ($remove as $string_to_remove) {
    $name = str_replace($string_to_remove, '', $name);
  }

  return $name;
}

function _wk_to_machine_name($human_readable) {
  $machine_readable = strtolower($human_readable);
  $machine_readable = preg_replace("@['`]s@",'s',$machine_readable);
  $machine_readable = preg_replace('@[^a-z0-9_]+@','-',$machine_readable);
  return $machine_readable;
}

/**
 * Return the URL to the specified site, or FALSE if the
 * branch does not have a site.
 */
function wk_branch_site_url($branch_term) {
  $term = $branch_term;
  if (is_array($term)) {
    $term = $term['tid'];
  }
  $e = entity_metadata_wrapper("taxonomy_term", $term);
  $url = $e->field_external_site_url->value();
  if (empty($url)) {
    $domain = _regnum_domain_sitename_load($branch_term);
    if (!empty($domain)) {
      $url = $domain['scheme'] . '://' . $domain['subdomain'];
    }
    else {
      $url = FALSE;
    }
  }
  return $url;
}

function wk_branch_site_label($branch_term, $image_attributes = array(), $require_url = TRUE, $include_img = TRUE) {
  if (is_numeric($branch_term)) {
    $branch_term = taxonomy_term_load($branch_term);
  }
  if (is_object($branch_term)) {
    $branch_term = (array)$branch_term;
  }

  $url = wk_branch_site_url($branch_term);
  $title = $branch_term['name'];
  $description = strip_tags($branch_term['description']);
  $site_label = '';
  if ($url) {
    $site_label = l($title, $url, array('attributes' => array('title' => $description, 'class' => array('site-label'))));
  }
  elseif(!$require_url) {
    $site_label = "<b>$title</b>";
  }
  if (!empty($site_label) && $include_img) {
    $e = entity_metadata_wrapper("taxonomy_term", $branch_term['tid']);
    $img_info = $e->field_arms->value();
    if ($img_info) {
      $site_label = theme_image(array("path" => $img_info['uri'], "title" => $title, "attributes" => $image_attributes)) . " $site_label";
    }
  }
  return $site_label;
}

function wk_branch_site_label_list($branch_list, $image_attributes = array(), $require_url = TRUE) {
  $list = array();
  foreach ($branch_list as $branch_term) {
    $site_label = wk_branch_site_label($branch_term, $image_attributes, $require_url);
    if (!empty($site_label)) {
      $list[] = $site_label;
    }
  }
  return $list;
}

function _wk_full_parentage($domain = FALSE) {
  $result = '';
  $parent_terms = regnum_domain_parent_term_list($domain);
  if (!empty($parent_terms)) {
    foreach ($parent_terms as $branch_term) {
      if (!empty($result)) {
        $result .= t(' of the ');
      }
      $result .= wk_branch_site_label($branch_term, array(), FALSE, FALSE);
    }
  }

  return $result;
}

/**
 * Create a new custom menu for a branch group.  We create separate
 * menus for every group (rather than making a fixed dynamic menu that
 * adapts to the current domain) to make it easy for branch domain web
 * ministers to customize their main menu, if they wish.
 */
function _wk_create_branch_menu($branch_term, $homepage_path) {
  $branch_id = $branch_term->tid;
  $short_name = _wk_term_short_name($branch_term);
  $menu_name = _wk_to_machine_name(_wk_term_short_name($branch_term)) . '-main-menu';
  $menu_title = t('!name Main Menu', array('!name' => $short_name));
  $menu = array(
   'menu_name' => $menu_name,
   'title' => $menu_title,
   'description' => t('Contains the custom menu items for the main menu of the !name', array('!name' => $branch_term->name)),
  );

  $menu_items = array(
    array(
      'link_title' => t("Welcome"),
      'link_path' => "$homepage_path",
    ),
    array(
      'link_title' => t("Calendar"),
      'link_path' => "calendar/$branch_id",
    ),
    array(
      'link_title' => t("Meetings"),
      'link_path' => "meetings/$branch_id",
    ),
    array(
      'link_title' => t("Events"),
      'link_path' => "events/$branch_id",
    ),
    array(
      'link_title' => t("Officers"),
      'link_path' => "officers/$branch_id",
    ),
  );
  // Try to load the specified menu name to find out if it already exists.
  if (!menu_load($menu_name)) {
    menu_save($menu);
    $weight = 0;
    foreach ($menu_items as $link) {
      $link += array(
        'menu_name' => $menu_name,
        'weight' => $weight,
        'expanded' => 0,
      );
      $mlid = menu_link_save($link);
      $weight += 10;
    }
  }
  return $menu;
}

function wk_officer_list($branch) {
  // Find all of the officer nodes for the specified branch
  $query = new EntityFieldQuery();
  $query = $query->entityCondition('entity_type','node')
    ->entityCondition('bundle', array('officers'))
    ->propertyCondition('status', 1)
    ->fieldCondition('taxonomy_vocabulary_2', 'tid', $branch, '=');
  $entities = $query->execute();

  // Create a mapping from the office tid to
  // the officer node
  $officer_map = array();
  foreach ($entities['node'] as $nid => $info) {
    $e = entity_metadata_wrapper('node', $nid);
    $office = $e->field_office->value();
    $office = reset($office);
    $officer_map[$office->tid] = $e;
  }

  // Iterate over the officer tree to build the page
  $officer_tree = taxonomy_get_tree(3);
  $page = array('#prefix' => '<div id="officers">', '#suffix' => '</div>');
  foreach ($officer_tree as $office_collection) {
    // The terms that are collections of officers
    // are those with depth == 0
    if ($office_collection->depth == 0) {
      $fn = '_wk_officer_list_section_' . strtolower(strtr($office_collection->name, " -", "__"));
      if (!function_exists($fn)) {
        $fn = '_wk_officer_list_section_officers';
      }
      $section_contents = $fn($branch, $officer_tree, $officer_map, $office_collection);
      if (!empty($section_contents)) {
        $page[$office_collection->name]['title'] = array('#markup' => '<h2>' . $office_collection->name . '</h2>');
        $page[$office_collection->name]['offices'] = $section_contents;
      }
    }
  }
  return $page;
}

function _wk_officer_list_section_regent($branch, $officer_tree, $officer_map, $office_collection) {
  $section_parent = $office_collection->tid;
  return array();
}

function _wk_officer_list_section_officers($branch, $officer_tree, $officer_map, $office_collection) {
  $section_parent = $office_collection->tid;
  $section_contents = array();
  foreach ($officer_tree as $office) {
    if (in_array($section_parent, $office->parents)) {
      // TODO: Maybe label each office on a case-by-case basis as required or not required, and set $show_vacancies based on that?
      $show_vacancies = FALSE;
      $info = array('#prefix' => '<div class="office-summary third-width">', '#suffix' => '</div>', '#office' => $office);
      //$e = entity_metadata_wrapper("taxonomy_term", $office->tid);
      $t = taxonomy_term_load($office->tid);
      $info['badge'] = field_view_field("taxonomy_term", $t, "field_badge");
      $info['badge']['#weight'] = -10;
      if (array_key_exists($office->tid, $officer_map)) {
        $e = $officer_map[$office->tid];
        // $info['node'] = $e;
        $nid = $e->getIdentifier();
        $url = url("node/$nid");
        $info['badge']['#prefix'] = "<a href='$url'>";
        $info['badge']['#suffix'] = "</a>";
        $info['#nid'] = $nid;
        $members = _wk_group_members($nid);
        foreach ($members as $id => $member) {
          if (!empty($member['title']) && (!array_key_exists('members', $info) || ($member['weight'] < 0))) {
            $info['members'][$id] = _wk_build_office_member_display($member['title'], $member['user']->name, $nid);
          }
        }
        if (!array_key_exists('members', $info)) {
          $info['members'][] = _wk_build_office_member_display($e->title->value(), $e->author->value()->name, $nid);
        }
      }
      elseif ($show_vacancies) {
        $info['members'][] = _wk_build_office_member_display($office->name, t('Vacant'));
      }
      if (array_key_exists('members', $info)) {
        $info['members']['#prefix'] = '<div class="office-members">';
        $info['members']['#suffix'] = '</div>';
        $section_contents[$office->name] = $info;
      }
    }
  }
  return $section_contents;
}

function _wk_build_office_member_display($title, $name, $nid = 0) {
  $linked_title = $title;
  $linked_name = $name;
  if ($nid) {
    $url = "node/$nid";
    $linked_title = l($title, $url);
    $linked_name = l($name, $url);
  }
  return array(
    '#prefix' => '<div class="office-member">',
    'title' => array(
      '#prefix' => "<div class='officer-title'>",
      '#markup' => $linked_title,
      '#suffix' => "</div>",
    ),
    'name' => array(
      '#prefix' => "<div class='officer-name'>",
      '#markup' => $linked_name,
      '#suffix' => "</div>",
    ),
    '#suffix' => '</div>',
  );
}
function _wk_group_members($gid, $group_type = 'node') {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'og_membership')
    ->propertyCondition('gid', $gid, '=')
    ->propertyCondition('group_type', $group_type, '=')
    ->fieldOrderBy('field_weight', 'value')
    ->execute();
  $members = array();
  if (array_key_exists('og_membership', $result)) {
    foreach ($result['og_membership'] as $id => $info) {
      $e = entity_metadata_wrapper("og_membership", $id);
      $type_of_deputy = $e->field_type_of_deputy->value();
      $weight = $e->field_weight->value(); // todo: just sort by weight
      $user = $e->entity->value();
      $members[$user->uid] = array(
        'user' => $user,
        'title' => $type_of_deputy,
        'weight' => $weight,
      );
    }
  }
  return $members;
}
